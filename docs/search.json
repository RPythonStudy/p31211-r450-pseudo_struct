[
  {
    "objectID": "posts/python.html",
    "href": "posts/python.html",
    "title": "python 프로젝트 설정",
    "section": "",
    "text": "모듈 임포트 우선순위\nsys.path에 기록됩니다. 0: 현재 디렉토리 1: 표준 라이브러리 압축 2: 표준 라이브러입 3: 확장 라이브러리 4: pip\n확인방법은\npython -c \"import sys; print('\\n'.join(f'{i}: {p}' for i, p in enumerate(sys.path)))\"\n예시로 main.py에서 logger 모듈을 임포할 때, main.py와 같은 경로에 logger가 있으므로 그대로 임포트하면 됩니다. sys.path[0]에 현재 디렉토리가 포함되어 있기 때문입니다.\n\n\n개발자 편집모드\n개발자 편집모드는 sys.path[4]에 src 디렉토리를 추가합니다. 이로 인해 src 디렉토리 내의 모듈을 임포트할 수 있습니다. 예를 들어, src/logger.py가 있다면, main.py에서 from logger import logger로 임포트할 수 있습니다."
  },
  {
    "objectID": "posts/vault.html",
    "href": "posts/vault.html",
    "title": "Vault 설치 및 설정",
    "section": "",
    "text": "개인정보보호\n\n의무기록시스템(EMR)으로부터 추출된 의료정보는 중앙 로깅 서버에 모든 접근 및 다운로드 이력이 기록되어야 한다.\n가명화 또는 익명화 조치를 수행하는 책임자는 해당 조치의 수행 이력 및 방식에 대한 기록(log)을 남겨야 하며, 이 기록은 감사를 위해 보존되어야 한다.\n임상연구를 위해 가명화된 환자 식별자는 동일 환자의 반복 가명화 시에도 일관되게 동일한 가명 식별자로 생성되어야 하며, 이를 통해 시간대별 또는 다기관 간 데이터 통합 및 분석이 가능하도록 해야 한다.\n가명화된 정보는 적법한 원내 승인 절차(예: 연구윤리위원회(IRB) 승인 등)에 따른 요청이 있을 경우, 정당한 목적 하에 원 식별자에 대한 역추적이 가능하도록 체계가 마련되어야 한다.\n\n\n\nHashCorp Vault\n이 프로젝트에서는 가명화를 위해 HashCorp Vault를 사용하며, 가명화(익명화)담당자가 HashCorp Vault를 사용하여 가명화 키를 관리한다고 가정하였다.\n\n\n설치\n운영체제별로… 여기서는 wsl2 ubuntu\n\n시스템 그룹으로 등록\nsudo groupadd --system vault\n그룹목록을 확인\ngetent group\n\n\n시스템사용자로 등록\nsudo useradd --system --home /etc/vault --shell /bin/false --gid vault vault\ngetent passwd vault\n\n\n1. HashiCorp GPG 키 등록\ncurl -fsSL https://apt.releases.hashicorp.com/gpg | sudo gpg --dearmor -o /usr/share/keyrings/hashicorp-archive-keyring.gpg\n\n\n2. HashiCorp 저장소 추가\necho \"deb [signed-by=/usr/share/keyrings/hashicorp-archive-keyring.gpg] https://apt.releases.hashicorp.com $(lsb_release -cs) main\" | sudo tee /etc/apt/sources.list.d/hashicorp.list\n\n\n3. 패키지 정보 갱신\nsudo apt update\n\n\n4. Vault 설치\nsudo apt install vault\n\n\n설치검증\nvault -v\ncf) vault -version 명령은 실행되지 않으니 주의를 요한다.\n\n\n필수 디렉토리 권한설정\n설정파일용\nsudo mkdir -p /etc/vault\n데이터 스토리지용\nsudo mkdir -p /var/lib/vault\n데이터 스토리지용\nsudo mkdir -p /var/log/vault\n재귀적으로 권한설정\nsudo chown -R vault:vault /etc/vault /var/lib/vault /var/log/vault\nsudo chmod 700 /etc/vault /var/lib/vault\n\n\n설정파일 만들기\n\n\n\nvault.hcl\n\n# /etc/vault/vault.hcl\n\n# 1) 스토리지 백엔드\nstorage \"file\" {\n  path = \"/var/lib/vault\"\n}\n\n# 2) 리스너 (TLS 적용 권장)\nlistener \"tcp\" {\n  address     = \"0.0.0.0:8200\"\n  tls_disable = 1            # 운영환경에서는 tls_disable = 0 과 cert/key 설정 사용\n}\n\n# 3) UI 활성화\nui = true\n\n# 4) 감사로그 (선택)\naudit \"file\" {\n  file_path = \"/var/log/vault/audit.log\"\n  log_raw   = true\n}\n\n\n설정파일에 대한 사용자 및 권한설정\nsudo chown vault:vault /etc/vault/vault.hcl\nsudo chmod 640 /etc/vault/vault.hcl\n\n\nsystemd\n/etc/systemd/system/vault.service 를 다음과 같이 작성\n[Unit]\nDescription=HashiCorp Vault - Secret Management\nAfter=network-online.target\nWants=network-online.target\n\n[Service]\nUser=vault\nGroup=vault\nExecStart=/usr/bin/vault server -config=/etc/vault/vault.hcl\nExecReload=/bin/kill -HUP $MAINPID\nRestart=on-failure\nLimitNOFILE=65536\n\n[Install]\nWantedBy=multi-user.target\n사용자변경 및 권한설정\nsudo chown root:root /etc/systemd/system/vault.service\nsudo chmod 644 /etc/systemd/system/vault.service\n\n\n기동\nsudo systemctl daemon-reload\nsudo systemctl enable vault\n```bash\nsudo systemctl start vault \nsudo systemctl status vault\n\n\n\n최초설정\nsudo vault operator init\nHTTPS와 HTTP 불일치를 해결을 위한 인자로 주어서 초기설정 시작\n sudo vault operator init -address=\"http://127.0.0.1:8200\"\n키와 토큰을 잘 저장한 후\nvault operator unseal &lt;UNSEAL_KEY&gt;\nSealed: false로 바뀐 것을 확인한 후"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Blog",
    "section": "",
    "text": "Order By\n       Default\n         \n          Title\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Author\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n\n\n\n민감정보관리시스템 구축\n\n\n\n\n\n\nVault\n\n\n\n개인정보보호 위해 HashiCorp Vault 구축\n\n\n\n\n\nJun 18, 2025\n\n\nBenKorea\n\n\n\n\n\n\n\n\n\n\n\n\n인증시스템 구축\n\n\n\n\n\n\nAuthentication\n\n\nKeyCloak\n\n\n\n게인정보보호 위해 KeyCloak 구축\n\n\n\n\n\nJun 22, 2024\n\n\nBenKorea feat Copilot\n\n\n\n\n\n\n\n\n\n\n\n\n개발기록\n\n\n\n\n\n\ndeveolpment\n\n\n\n개발과정을 기록하여 나의 기억과 협업에 도움이 되고자 함\n\n\n\n\n\nJun 18, 2025\n\n\nBenKorea\n\n\n\n\n\n\n\n\n\n\n\n\n가명화\n\n\n\n\n\n\n\n\n\n\n\nJun 20, 2025\n\n\nBenKorea feat Copilot\n\n\n\n\n\n\n\n\n\n\n\n\npython 프로젝트 설정\n\n\n\n\n\n\n\n\n\n\n\nJun 18, 2025\n\n\nBenKorea\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/development/authentication/authentication.html",
    "href": "posts/development/authentication/authentication.html",
    "title": "인증시스템구축",
    "section": "",
    "text": "인증 시스템 선택\n\n개인정보보호법 준수를 위해 사용자별 권한 관리 필요\n오픈소스 Keycloak 도입 결정\n\n\n\n사용자 역할 정의\n\n관리자(nmdose-superuser):\n\n시스템 설정, 사용자 관리, 감사 기록 조회 등 모든 권한 보유\n\n일반 사용자(nmdose-user):\n\n선량 정보 조회 등 제한된 기능만 접근 가능\n\n\n\n\nkeycloak 설치\n\n인증 서버는 nmdose 시스템과 분리된 서버에 설치하는 것이 이상적이나, 개발 단계에서는 Docker를 활용해 분리된 서버를 모사함\n운영(Production) 환경에서는 별도의 데이터베이스 지정 및 HTTPS(TLS) 인증서 적용 필요\n병원 내부망(도메인 없는 사설망)에서는 공인 인증서가 아닌 “자가서명 인증서” 또는 “사내 CA 인증서”를 사용 필요하므로\n\nubuntu에 제공되는 openssl로 자가서명 인증서를 발급\n\n\n\n\n\nbash\n\nopenssl req \\\n  -x509 \\\n  -newkey rsa:2048 \\\n  -keyout mykey.key \\\n  -out mycert.crt \\\n  -days 365 \\\n  -nodes \\\n  -subj \"/C=KR/ST=Seoul/L=Seoul/O=KCCH/OU=RPythonStudy/CN=localhost\" \\\n  -addext \"subjectAltName = DNS:localhost, IP:127.0.0.1, DNS:keycloak-server\"\n\n\n업계표준에 따른 저장폴더는\n\n\n\nbash\n\nsudo mkdir -p /etc/nmdose/certs/\n\n\n\n\n\nbash\n\nsudo cp ~/projects/keycloak-server/mycert.crt /etc/nmdose/certs/server.crt\nsudo cp ~/projects/keycloak-server/mykey.key /etc/nmdose/certs/server.key\n\n\n파일의 권한에 대해서도 항상 신경써야 한다.\n\n\n\nbash\n\nsudo chmod 644 /etc/nmdose/certs/server.key\nsudo chmod 644 /etc/nmdose/certs/server.crt\n\n\n그러나 chmod 644는 보안정책에 위반되므로 vault로 동적으로 주입하는 것으로 전환해야 함.\n아래는 chmod 644에서 성공하기는 했음. 그러나 vault로 수정이 필요함.\n매뉴얼에 따르면 keycloak production mode는 3가지 설정이 필요하다. - HTTPS - hostname - TLS\n커맨드라인에서 bin/kc.[sh|bat] start –https-certificate-file=/path/to/certfile.pem –https-certificate-key-file=/path/to/keyfile.pem 명령으로 HTTPS/TLS에 필요한 certificate 파일과 key 파일의 경로를 전달한다.\n\n\n\nprojects/keycloak-server/docker-compose.yml\n\nversion: \"3.8\"\n\nservices:\n  postgres:\n    image: postgres:16\n    container_name: nmdose-postgres\n    restart: always\n    environment:\n      POSTGRES_DB: keycloak\n      POSTGRES_USER: keycloak\n      POSTGRES_PASSWORD: keycloakpass\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\n    networks:\n      - nmdose-net\n\n  keycloak:\n    image: quay.io/keycloak/keycloak:25.0.0\n    container_name: nmdose-keycloak\n    command:\n      - start\n      - --https-certificate-file=/etc/x509/https/tls.crt\n      - --https-certificate-key-file=/etc/x509/https/tls.key\n      - --db=postgres\n      - --db-url-host=postgres\n      - --db-username=keycloak\n      - --db-password=keycloakpass\n      - --db-database=keycloak\n      - --hostname=localhost\n    environment:\n      KC_HEALTH_ENABLED: \"true\"\n      KC_METRICS_ENABLED: \"true\"\n      KEYCLOAK_ADMIN: admin\n      KEYCLOAK_ADMIN_PASSWORD: adminpass\n    volumes:\n      # 인증서 마운트: 호스트 → 컨테이너\n      - /etc/nmdose/certs/server.crt:/etc/x509/https/tls.crt:ro\n      - /etc/nmdose/certs/server.key:/etc/x509/https/tls.key:ro\n    depends_on:\n      - postgres\n    ports:\n      - \"8443:8443\"\n    networks:\n      - nmdose-net\n\nvolumes:\n  postgres_data:\n\nnetworks:\n  nmdose-net:\n    driver: bridge\n\n\n\n\n\nbash\n\nsudo docker compose up -d\n\n\n\n\n\nbash\n\nsudo docker compose ps",
    "crumbs": [
      "개발기록",
      "인증시스템구축"
    ]
  },
  {
    "objectID": "posts/pseudonymize_files.html",
    "href": "posts/pseudonymize_files.html",
    "title": "가명화",
    "section": "",
    "text": "R에서도 로그레벨에 따른 출력설정이 가능하므로 이 프로젝트에서 logger chunk에서 이를 구현하였습니다. 이를 위해서는 미리 .Rprofile에 코딩하는 등의 사전준비가 필요하므로 지금은 단순히 - log_debug() - log_info() - log_warn() - log_error() 중에 하나를 선택하여 메시지를 출력함으로써 프로그램의 진행상황과 오류 메시지를 체계적으로 관리할 수 있도록 하였습니다.\n\nif (!requireNamespace(\"logger\", quietly = TRUE)) install.packages(\"logger\")\nlibrary(logger)"
  },
  {
    "objectID": "posts/pseudonymize_files.html#로그설정",
    "href": "posts/pseudonymize_files.html#로그설정",
    "title": "가명화",
    "section": "",
    "text": "R에서도 로그레벨에 따른 출력설정이 가능하므로 이 프로젝트에서 logger chunk에서 이를 구현하였습니다. 이를 위해서는 미리 .Rprofile에 코딩하는 등의 사전준비가 필요하므로 지금은 단순히 - log_debug() - log_info() - log_warn() - log_error() 중에 하나를 선택하여 메시지를 출력함으로써 프로그램의 진행상황과 오류 메시지를 체계적으로 관리할 수 있도록 하였습니다.\n\nif (!requireNamespace(\"logger\", quietly = TRUE)) install.packages(\"logger\")\nlibrary(logger)"
  },
  {
    "objectID": "posts/pseudonymize_files.html#파일-읽어오기",
    "href": "posts/pseudonymize_files.html#파일-읽어오기",
    "title": "가명화",
    "section": "파일 읽어오기",
    "text": "파일 읽어오기\nlist.files를 이용해서 파일이름들을 리스트로 가져오는 가장 일반적인 방식입니다. 향후 진행될 가명화를 위해서 파일이름 리스트에서 확장자를 제거한 후, register_numbers라는 문자형 벡터(character vector)로 생성합니다.\n\nfile_list &lt;- list.files(\"../data/raw\", pattern = \"\\\\.txt$\")\nregister_numbers &lt;- tools::file_path_sans_ext(file_list)\nlog_info(\"등록번호 추출 완료: {paste(register_numbers, collapse=', ')}\")"
  },
  {
    "objectID": "posts/pseudonymize_files.html#파일이름-가명화",
    "href": "posts/pseudonymize_files.html#파일이름-가명화",
    "title": "가명화",
    "section": "파일이름 가명화",
    "text": "파일이름 가명화\n본 프로젝트에서는 파일명이 등록번호로 구성되어 있다고 가정합니다. 따라서 파일명을 가명화하는 과정이 필요합니다. 가명화 방식으로는 가역적이며 일관성을 보장하는 가명화(reversible deterministic pseudonymization)를 채택하였습니다. 이를 위해 원본 형식을 유지하는 형식보존암호화(format-preserving encryption)를 적용하였으며, 미국 NIST에서 권장하는 알고리즘을 구현한 FF3 파이썬 패키지를 활용하였습니다.\n\nif (!requireNamespace(\"reticulate\", quietly = TRUE)) install.packages(\"reticulate\")\nlibrary(reticulate)\n\n# 파이썬 모듈 임포트\nff3 &lt;- import(\"ff3\")\n\n# FF3Cipher 객체 생성 (키, 트윅, 알파벳은 파이썬과 동일하게 지정)\nKEY &lt;- \"0123456789abcdef0123456789abcdef\"\nTWEAK &lt;- \"abcdef12345678\"\nALPHABET &lt;- \"0123456789\"\ncipher &lt;- ff3$FF3Cipher$withCustomAlphabet(KEY, TWEAK, ALPHABET)\n\n# 등록번호 벡터를 FF3로 가명화\npseudonym_list &lt;- sapply(register_numbers, cipher$encrypt)\nlog_info(\"가명화된 등록번호: {paste(pseudonym_list, collapse=', ')}\")\n\n# 결과 확인\nresult_df &lt;- data.frame(\n  original_id = register_numbers,\n  pseudonym = pseudonym_list,\n  stringsAsFactors = FALSE\n)"
  },
  {
    "objectID": "posts/pseudonymize_files.html#파일이름-복호화",
    "href": "posts/pseudonymize_files.html#파일이름-복호화",
    "title": "가명화",
    "section": "파일이름 복호화",
    "text": "파일이름 복호화\n\n# FF3Cipher 객체는 이미 생성되어 있다고 가정합니다.\n# (cipher &lt;- ff3$FF3Cipher$withCustomAlphabet(KEY, TWEAK, ALPHABET))\n\n# 복호화: pseudonym_list를 원본으로 되돌리기\ndecrypted_list &lt;- sapply(pseudonym_list, cipher$decrypt)\n\n# 복호화 결과 확인\nresult_df$decrypted &lt;- decrypted_list\nprint(result_df)\n\n[1] original_id decrypted  \n&lt;0 rows&gt; (or 0-length row.names)"
  },
  {
    "objectID": "posts/pseudonymize_files.html#복호화-검증",
    "href": "posts/pseudonymize_files.html#복호화-검증",
    "title": "가명화",
    "section": "복호화 검증",
    "text": "복호화 검증\n\n# 복호화 결과가 원본과 동일한지 검증\nall_equal &lt;- all(result_df$original_id == result_df$decrypted)\nif (all_equal) {\n  log_success(\"복호화 결과가 원본과 완전히 일치합니다.\")\n} else {\n  log_error(\"복호화 결과와 원본이 일치하지 않는 값이 있습니다.\")\n  print(result_df[result_df$original_id != result_df$decrypted, ])\n}"
  },
  {
    "objectID": "posts/pseudonymize_files.html#파일-내용-읽어오기",
    "href": "posts/pseudonymize_files.html#파일-내용-읽어오기",
    "title": "가명화",
    "section": "파일 내용 읽어오기",
    "text": "파일 내용 읽어오기\n이 단계에서는 가명화된 파일명과 매칭되는 원본 파일의 내용을 읽어옵니다.\n파일마다 인코딩이 다를 수 있으므로, 인코딩 자동 감지 및 변환을 함께 처리하는 것이 좋습니다.\n\nif (!requireNamespace(\"stringi\", quietly = TRUE)) install.packages(\"stringi\")\nlibrary(stringi)\n\n# 파일 경로 벡터 생성\nfile_paths &lt;- file.path(\"data/raw\", file_list)\n\n# 인코딩 감지 없이 UTF-8로 처리 (실패 시 깨질 수 있음)\nread_file_content &lt;- function(path) {\n  content &lt;- stringi::stri_read_lines(path, encoding = \"UTF-8\")  # 인코딩 고정\n  paste(content, collapse = \"\\n\")\n}\n\nfile_contents &lt;- lapply(file_paths, read_file_content)\n\n# 데이터프레임에 내용 추가\nresult_df$content &lt;- file_contents\n\n# 일부 결과 확인\nprint(result_df[, c(\"original_id\", \"pseudonym\", \"content\")])\n\n하지만 위 코드에서 encoding을 “UTF-8”로 지정하면 stringi::stri_read_lines 함수에서 오류가 발생할 수 있으므로, 인코딩을 자동 감지하도록 아래와 같이 수정해야 합니다.\n\nif (!requireNamespace(\"stringi\", quietly = TRUE)) install.packages(\"stringi\")\nlibrary(stringi)\n\n# 파일 경로 벡터 생성\nfile_paths &lt;- file.path(\"data/raw\", file_list)\n\n# 인코딩 감지 후 해당 인코딩으로 파일 읽기 및 로그 기록 (glue 문법 사용)\nread_file_content &lt;- function(path) {\n  raw_bytes &lt;- readBin(path, what = \"raw\", n = file.info(path)$size)\n  detected &lt;- stringi::stri_enc_detect(raw_bytes)[[1]]\n  best &lt;- detected[1, ]\n  log_info(\"파일 [{path}]의 감지된 인코딩: {best$Encoding} (신뢰도: {round(best$Confidence, 2)})\")\n  content &lt;- stringi::stri_read_lines(path, encoding = best$Encoding)\n  paste(content, collapse = \"\\n\")\n}\n\nfile_contents &lt;- lapply(file_paths, read_file_content)\n\n# 데이터프레임에 내용 추가\nresult_df$content &lt;- file_contents\n\n# 총 파일 개수 로그로 출력\nlog_success(\"총 {length(file_paths)}개의 파일을 성공적으로 읽었습니다.\")"
  },
  {
    "objectID": "posts/development/secret-management.html",
    "href": "posts/development/secret-management.html",
    "title": "민감정보관리시스템 구축",
    "section": "",
    "text": "Vault는 unseal key가 있어 필요시 이를 이용해서 root 권한으로 접속이 가능하다.\n다섯개로 이루어지 이 키들은 각각 다른 사람이 보관하는 것이 추천된다.\n따라서 이를 vault 관리위원회라 하고 각자 1개씩의 unseal key를 보관하도록 상상하였다.\n프린터를 하여 물리적인 금고에 보관하는 것을 최상위 보안방법이라 생각되지만 현실적인 타협도 고려된다.\n위원회의 구성은 의무기록의 가명화에 대한 책임이 있는 사람들로 구성하는 것이 좋을 것 같다.\n어차피 위원회가 만들어진다면 가명화정보관리위원회 또는 개인정보보호위원회라 칭하고 그 역할을 규정해도 좋을 것이다.",
    "crumbs": [
      "개발기록",
      "민감정보관리시스템 구축"
    ]
  },
  {
    "objectID": "posts/development/authentication.html",
    "href": "posts/development/authentication.html",
    "title": "인증시스템 구축",
    "section": "",
    "text": "0.1 인증 시스템 선택\n\n개인정보보호법 준수를 위해 사용자별 권한 관리 필요\n오픈소스 Keycloak 도입 결정\n\n\n\n0.2 사용자 역할 정의\n\n관리자(nmdose-superuser):\n\n시스템 설정, 사용자 관리, 감사 기록 조회 등 모든 권한 보유\n\n일반 사용자(nmdose-user):\n\n선량 정보 조회 등 제한된 기능만 접근 가능\n\n\n\n\n0.3 keycloak 설치\n\n인증 서버는 nmdose 시스템과 분리된 서버에 설치하는 것이 이상적이나, 개발 단계에서는 Docker를 활용해 분리된 서버를 모사함\n운영(Production) 환경에서는 별도의 데이터베이스 지정 및 HTTPS(TLS) 인증서 적용 필요\n병원 내부망(도메인 없는 사설망)에서는 공인 인증서가 아닌 “자가서명 인증서” 또는 “사내 CA 인증서”를 사용 필요하므로\n\nubuntu에 제공되는 openssl로 자가서명 인증서를 발급\n\n\n\n\n\nbash\n\nopenssl req \\\n  -x509 \\\n  -newkey rsa:2048 \\\n  -keyout mykey.key \\\n  -out mycert.crt \\\n  -days 365 \\\n  -nodes \\\n  -subj \"/C=KR/ST=Seoul/L=Seoul/O=KCCH/OU=RPythonStudy/CN=localhost\" \\\n  -addext \"subjectAltName = DNS:localhost, IP:127.0.0.1, DNS:keycloak-server\"\n\n\n업계표준에 따른 저장폴더는\n\n\n\nbash\n\nsudo mkdir -p /etc/nmdose/certs/\n\n\n\n\n\nbash\n\nsudo cp ~/projects/keycloak-server/mycert.crt /etc/nmdose/certs/server.crt\nsudo cp ~/projects/keycloak-server/mykey.key /etc/nmdose/certs/server.key\n\n\n파일의 권한에 대해서도 항상 신경써야 한다.\n\n\n\nbash\n\nsudo chmod 644 /etc/nmdose/certs/server.key\nsudo chmod 644 /etc/nmdose/certs/server.crt\n\n\n그러나 chmod 644는 보안정책에 위반되므로 vault로 동적으로 주입하는 것으로 전환해야 함.\n아래는 chmod 644에서 성공하기는 했음. 그러나 vault로 수정이 필요함.\n매뉴얼에 따르면 keycloak production mode는 3가지 설정이 필요하다. - HTTPS - hostname - TLS\n커맨드라인에서 bin/kc.[sh|bat] start –https-certificate-file=/path/to/certfile.pem –https-certificate-key-file=/path/to/keyfile.pem 명령으로 HTTPS/TLS에 필요한 certificate 파일과 key 파일의 경로를 전달한다.\n\n\n\nprojects/keycloak-server/docker-compose.yml\n\nversion: \"3.8\"\n\nservices:\n  postgres:\n    image: postgres:16\n    container_name: nmdose-postgres\n    restart: always\n    environment:\n      POSTGRES_DB: keycloak\n      POSTGRES_USER: keycloak\n      POSTGRES_PASSWORD: keycloakpass\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\n    networks:\n      - nmdose-net\n\n  keycloak:\n    image: quay.io/keycloak/keycloak:25.0.0\n    container_name: nmdose-keycloak\n    command:\n      - start\n      - --https-certificate-file=/etc/x509/https/tls.crt\n      - --https-certificate-key-file=/etc/x509/https/tls.key\n      - --db=postgres\n      - --db-url-host=postgres\n      - --db-username=keycloak\n      - --db-password=keycloakpass\n      - --db-database=keycloak\n      - --hostname=localhost\n    environment:\n      KC_HEALTH_ENABLED: \"true\"\n      KC_METRICS_ENABLED: \"true\"\n      KEYCLOAK_ADMIN: admin\n      KEYCLOAK_ADMIN_PASSWORD: adminpass\n    volumes:\n      # 인증서 마운트: 호스트 → 컨테이너\n      - /etc/nmdose/certs/server.crt:/etc/x509/https/tls.crt:ro\n      - /etc/nmdose/certs/server.key:/etc/x509/https/tls.key:ro\n    depends_on:\n      - postgres\n    ports:\n      - \"8443:8443\"\n    networks:\n      - nmdose-net\n\nvolumes:\n  postgres_data:\n\nnetworks:\n  nmdose-net:\n    driver: bridge\n\n\n\n\n\nbash\n\nsudo docker compose up -d\n\n\n\n\n\nbash\n\nsudo docker compose ps",
    "crumbs": [
      "개발기록",
      "인증시스템 구축"
    ]
  },
  {
    "objectID": "posts/development/secret-management.html#개인정보보호",
    "href": "posts/development/secret-management.html#개인정보보호",
    "title": "비밀관리시스템구축",
    "section": "",
    "text": "의무기록시스템(EMR)으로부터 추출된 의료정보는 중앙 로깅 서버에 모든 접근 및 다운로드 이력이 기록되어야 한다.\n가명화 또는 익명화 조치를 수행하는 책임자는 해당 조치의 수행 이력 및 방식에 대한 기록(log)을 남겨야 하며, 이 기록은 감사를 위해 보존되어야 한다.\n임상연구를 위해 가명화된 환자 식별자는 동일 환자의 반복 가명화 시에도 일관되게 동일한 가명 식별자로 생성되어야 하며, 이를 통해 시간대별 또는 다기관 간 데이터 통합 및 분석이 가능하도록 해야 한다.\n가명화된 정보는 적법한 원내 승인 절차(예: 연구윤리위원회(IRB) 승인 등)에 따른 요청이 있을 경우, 정당한 목적 하에 원 식별자에 대한 역추적이 가능하도록 체계가 마련되어야 한다.\n\n\n\n이 프로젝트에서는 가명화를 위해 HashCorp Vault를 사용하며, 가명화(익명화)담당자가 HashCorp Vault를 사용하여 가명화 키를 관리한다고 가정하였다.\n\n\n\n운영체제별로… 여기서는 wsl2 ubuntu\n\n\nsudo groupadd --system vault\n그룹목록을 확인\ngetent group\n\n\n\nsudo useradd --system --home /etc/vault --shell /bin/false --gid vault vault\ngetent passwd vault\n\n\n\ncurl -fsSL https://apt.releases.hashicorp.com/gpg | sudo gpg --dearmor -o /usr/share/keyrings/hashicorp-archive-keyring.gpg\n\n\n\necho \"deb [signed-by=/usr/share/keyrings/hashicorp-archive-keyring.gpg] https://apt.releases.hashicorp.com $(lsb_release -cs) main\" | sudo tee /etc/apt/sources.list.d/hashicorp.list\n\n\n\nsudo apt update\n\n\n\nsudo apt install vault\n\n\n\nvault -v\ncf) vault -version 명령은 실행되지 않으니 주의를 요한다.\n\n\n\n설정파일용\nsudo mkdir -p /etc/vault\n데이터 스토리지용\nsudo mkdir -p /var/lib/vault\n데이터 스토리지용\nsudo mkdir -p /var/log/vault\n재귀적으로 권한설정\nsudo chown -R vault:vault /etc/vault /var/lib/vault /var/log/vault\nsudo chmod 700 /etc/vault /var/lib/vault\n\n\n\n\n\n\nvault.hcl\n\n# /etc/vault/vault.hcl\n\n# 1) 스토리지 백엔드\nstorage \"file\" {\n  path = \"/var/lib/vault\"\n}\n\n# 2) 리스너 (TLS 적용 권장)\nlistener \"tcp\" {\n  address     = \"0.0.0.0:8200\"\n  tls_disable = 1            # 운영환경에서는 tls_disable = 0 과 cert/key 설정 사용\n}\n\n# 3) UI 활성화\nui = true\n\n# 4) 감사로그 (선택)\naudit \"file\" {\n  file_path = \"/var/log/vault/audit.log\"\n  log_raw   = true\n}\n\n\n설정파일에 대한 사용자 및 권한설정\nsudo chown vault:vault /etc/vault/vault.hcl\nsudo chmod 640 /etc/vault/vault.hcl\n\n\n\n/etc/systemd/system/vault.service 를 다음과 같이 작성\n[Unit]\nDescription=HashiCorp Vault - Secret Management\nAfter=network-online.target\nWants=network-online.target\n\n[Service]\nUser=vault\nGroup=vault\nExecStart=/usr/bin/vault server -config=/etc/vault/vault.hcl\nExecReload=/bin/kill -HUP $MAINPID\nRestart=on-failure\nLimitNOFILE=65536\n\n[Install]\nWantedBy=multi-user.target\n사용자변경 및 권한설정\nsudo chown root:root /etc/systemd/system/vault.service\nsudo chmod 644 /etc/systemd/system/vault.service\n\n\n\nsudo systemctl daemon-reload\nsudo systemctl enable vault\n```bash\nsudo systemctl start vault \nsudo systemctl status vault\n\n\n\n\nsudo vault operator init\nHTTPS와 HTTP 불일치를 해결을 위한 인자로 주어서 초기설정 시작\n sudo vault operator init -address=\"http://127.0.0.1:8200\"\n키와 토큰을 잘 저장한 후\nvault operator unseal &lt;UNSEAL_KEY&gt;\nSealed: false로 바뀐 것을 확인한 후",
    "crumbs": [
      "개발기록",
      "비밀관리시스템구축"
    ]
  },
  {
    "objectID": "posts/development/secret-management.html#vault-관리위원회",
    "href": "posts/development/secret-management.html#vault-관리위원회",
    "title": "민감정보관리시스템 구축",
    "section": "",
    "text": "Vault는 unseal key가 있어 필요시 이를 이용해서 root 권한으로 접속이 가능하다.\n다섯개로 이루어지 이 키들은 각각 다른 사람이 보관하는 것이 추천된다.\n따라서 이를 vault 관리위원회라 하고 각자 1개씩의 unseal key를 보관하도록 상상하였다.\n프린터를 하여 물리적인 금고에 보관하는 것을 최상위 보안방법이라 생각되지만 현실적인 타협도 고려된다.\n위원회의 구성은 의무기록의 가명화에 대한 책임이 있는 사람들로 구성하는 것이 좋을 것 같다.\n어차피 위원회가 만들어진다면 가명화정보관리위원회 또는 개인정보보호위원회라 칭하고 그 역할을 규정해도 좋을 것이다.",
    "crumbs": [
      "개발기록",
      "민감정보관리시스템 구축"
    ]
  },
  {
    "objectID": "posts/development/secret-management.html#사용자계정-분류",
    "href": "posts/development/secret-management.html#사용자계정-분류",
    "title": "민감정보관리시스템 구축",
    "section": "2 사용자계정 분류",
    "text": "2 사용자계정 분류\n\n프로젝트의 민감정보를 관리하기 위해 권한별 사용자 계정을 분류하였다.\n\n\n2.1 Vault 관리자\n\nVault 시스템의 최상위관리자이다.\n계정이 따로 존재하지 않고 최초 설치시에 발급되는 root token을 사용하여 vault에 접속한다.\n초기설정 시 감사로그 (audit log)를 남길 수 있도록 최상위관리자는 설정을 해야 한다.\n필요한 사용자를 생성한다.\n\n\n\n2.2 Vault 사용자\n\nVault 관리자에 의해 생성된 사용자\nKeyCloak 인증서버에 주입해야 하는 HTTPS/TLS key/certicate를 보관해야 한다.\n가명화를 위한 key와 tweak를 보관해야 한다.\n\n가 인증과정에 필요로 하는 로써 프로젝트를 위한 정책들은 생성하고vault root 권한을 가지지 않은 사용자\n- 사용자계정로, Vault 서버의 설정 및 관리 작업을 수행합니다.\n\n\n2.3 HashCorp Vault\n이 프로젝트에서는 가명화를 위해 HashCorp Vault를 사용하며, 가명화(익명화)담당자가 HashCorp Vault를 사용하여 가명화 키를 관리한다고 가정하였다.\n\n\n2.4 설치\n운영체제별로… 여기서는 wsl2 ubuntu\n\n2.4.1 시스템 그룹으로 등록\nsudo groupadd --system vault\n그룹목록을 확인\ngetent group\n\n\n2.4.2 시스템사용자로 등록\nsudo useradd --system --home /etc/vault --shell /bin/false --gid vault vault\ngetent passwd vault\n\n\n2.4.3 1. HashiCorp GPG 키 등록\ncurl -fsSL https://apt.releases.hashicorp.com/gpg | sudo gpg --dearmor -o /usr/share/keyrings/hashicorp-archive-keyring.gpg\n\n\n2.4.4 2. HashiCorp 저장소 추가\necho \"deb [signed-by=/usr/share/keyrings/hashicorp-archive-keyring.gpg] https://apt.releases.hashicorp.com $(lsb_release -cs) main\" | sudo tee /etc/apt/sources.list.d/hashicorp.list\n\n\n2.4.5 3. 패키지 정보 갱신\nsudo apt update\n\n\n2.4.6 4. Vault 설치\nsudo apt install vault\n\n\n2.4.7 설치검증\nvault -v\ncf) vault -version 명령은 실행되지 않으니 주의를 요한다.\n\n\n2.4.8 필수 디렉토리 권한설정\n설정파일용\nsudo mkdir -p /etc/vault\n데이터 스토리지용\nsudo mkdir -p /var/lib/vault\n데이터 스토리지용\nsudo mkdir -p /var/log/vault\n재귀적으로 권한설정\nsudo chown -R vault:vault /etc/vault /var/lib/vault /var/log/vault\nsudo chmod 700 /etc/vault /var/lib/vault\n\n\n2.4.9 설정파일 만들기\n\n\n\nvault.hcl\n\n# /etc/vault/vault.hcl\n\n# 1) 스토리지 백엔드\nstorage \"file\" {\n  path = \"/var/lib/vault\"\n}\n\n# 2) 리스너 (TLS 적용 권장)\nlistener \"tcp\" {\n  address     = \"0.0.0.0:8200\"\n  tls_disable = 1            # 운영환경에서는 tls_disable = 0 과 cert/key 설정 사용\n}\n\n# 3) UI 활성화\nui = true\n\n# 4) 감사로그 (선택)\naudit \"file\" {\n  file_path = \"/var/log/vault/audit.log\"\n  log_raw   = true\n}\n\n\n설정파일에 대한 사용자 및 권한설정\nsudo chown vault:vault /etc/vault/vault.hcl\nsudo chmod 640 /etc/vault/vault.hcl\n\n\n2.4.10 systemd\n/etc/systemd/system/vault.service 를 다음과 같이 작성\n[Unit]\nDescription=HashiCorp Vault - Secret Management\nAfter=network-online.target\nWants=network-online.target\n\n[Service]\nUser=vault\nGroup=vault\nExecStart=/usr/bin/vault server -config=/etc/vault/vault.hcl\nExecReload=/bin/kill -HUP $MAINPID\nRestart=on-failure\nLimitNOFILE=65536\n\n[Install]\nWantedBy=multi-user.target\n사용자변경 및 권한설정\nsudo chown root:root /etc/systemd/system/vault.service\nsudo chmod 644 /etc/systemd/system/vault.service\n\n\n2.4.11 기동\nsudo systemctl daemon-reload\nsudo systemctl enable vault\n```bash\nsudo systemctl start vault \nsudo systemctl status vault\n\n\n\n2.5 최초설정\nsudo vault operator init\nHTTPS와 HTTP 불일치를 해결을 위한 인자로 주어서 초기설정 시작\n sudo vault operator init -address=\"http://127.0.0.1:8200\"\n키와 토큰을 잘 저장한 후\nvault operator unseal &lt;UNSEAL_KEY&gt;\nSealed: false로 바뀐 것을 확인한 후",
    "crumbs": [
      "개발기록",
      "민감정보관리시스템 구축"
    ]
  }
]