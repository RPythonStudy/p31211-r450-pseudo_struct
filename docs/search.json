[
  {
    "objectID": "posts/python.html",
    "href": "posts/python.html",
    "title": "python 프로젝트 설정",
    "section": "",
    "text": "0.1 모듈 임포트 우선순위\nsys.path에 기록됩니다. 0: 현재 디렉토리 1: 표준 라이브러리 압축 2: 표준 라이브러입 3: 확장 라이브러리 4: pip\n확인방법은\npython -c \"import sys; print('\\n'.join(f'{i}: {p}' for i, p in enumerate(sys.path)))\"\n예시로 main.py에서 logger 모듈을 임포할 때, main.py와 같은 경로에 logger가 있으므로 그대로 임포트하면 됩니다. sys.path[0]에 현재 디렉토리가 포함되어 있기 때문입니다.\n\n\n0.2 개발자 편집모드\n개발자 편집모드는 sys.path[4]에 src 디렉토리를 추가합니다. 이로 인해 src 디렉토리 내의 모듈을 임포트할 수 있습니다. 예를 들어, src/logger.py가 있다면, main.py에서 from logger import logger로 임포트할 수 있습니다."
  },
  {
    "objectID": "posts/vault.html",
    "href": "posts/vault.html",
    "title": "Vault 설치 및 설정",
    "section": "",
    "text": "개인정보보호\n\n의무기록시스템(EMR)으로부터 추출된 의료정보는 중앙 로깅 서버에 모든 접근 및 다운로드 이력이 기록되어야 한다.\n가명화 또는 익명화 조치를 수행하는 책임자는 해당 조치의 수행 이력 및 방식에 대한 기록(log)을 남겨야 하며, 이 기록은 감사를 위해 보존되어야 한다.\n임상연구를 위해 가명화된 환자 식별자는 동일 환자의 반복 가명화 시에도 일관되게 동일한 가명 식별자로 생성되어야 하며, 이를 통해 시간대별 또는 다기관 간 데이터 통합 및 분석이 가능하도록 해야 한다.\n가명화된 정보는 적법한 원내 승인 절차(예: 연구윤리위원회(IRB) 승인 등)에 따른 요청이 있을 경우, 정당한 목적 하에 원 식별자에 대한 역추적이 가능하도록 체계가 마련되어야 한다.\n\n\n\nHashCorp Vault\n이 프로젝트에서는 가명화를 위해 HashCorp Vault를 사용하며, 가명화(익명화)담당자가 HashCorp Vault를 사용하여 가명화 키를 관리한다고 가정하였다.\n\n\n설치\n운영체제별로… 여기서는 wsl2 ubuntu\n\n시스템 그룹으로 등록\nsudo groupadd --system vault\n그룹목록을 확인\ngetent group\n\n\n시스템사용자로 등록\nsudo useradd --system --home /etc/vault --shell /bin/false --gid vault vault\ngetent passwd vault\n\n\n1. HashiCorp GPG 키 등록\ncurl -fsSL https://apt.releases.hashicorp.com/gpg | sudo gpg --dearmor -o /usr/share/keyrings/hashicorp-archive-keyring.gpg\n\n\n2. HashiCorp 저장소 추가\necho \"deb [signed-by=/usr/share/keyrings/hashicorp-archive-keyring.gpg] https://apt.releases.hashicorp.com $(lsb_release -cs) main\" | sudo tee /etc/apt/sources.list.d/hashicorp.list\n\n\n3. 패키지 정보 갱신\nsudo apt update\n\n\n4. Vault 설치\nsudo apt install vault\n\n\n설치검증\nvault -v\ncf) vault -version 명령은 실행되지 않으니 주의를 요한다.\n\n\n필수 디렉토리 권한설정\n설정파일용\nsudo mkdir -p /etc/vault\n데이터 스토리지용\nsudo mkdir -p /var/lib/vault\n데이터 스토리지용\nsudo mkdir -p /var/log/vault\n재귀적으로 권한설정\nsudo chown -R vault:vault /etc/vault /var/lib/vault /var/log/vault\nsudo chmod 700 /etc/vault /var/lib/vault\n\n\n설정파일 만들기\n\n\n\nvault.hcl\n\n# /etc/vault/vault.hcl\n\n# 1) 스토리지 백엔드\nstorage \"file\" {\n  path = \"/var/lib/vault\"\n}\n\n# 2) 리스너 (TLS 적용 권장)\nlistener \"tcp\" {\n  address     = \"0.0.0.0:8200\"\n  tls_disable = 1            # 운영환경에서는 tls_disable = 0 과 cert/key 설정 사용\n}\n\n# 3) UI 활성화\nui = true\n\n# 4) 감사로그 (선택)\naudit \"file\" {\n  file_path = \"/var/log/vault/audit.log\"\n  log_raw   = true\n}\n\n\n설정파일에 대한 사용자 및 권한설정\nsudo chown vault:vault /etc/vault/vault.hcl\nsudo chmod 640 /etc/vault/vault.hcl\n\n\nsystemd\n/etc/systemd/system/vault.service 를 다음과 같이 작성\n[Unit]\nDescription=HashiCorp Vault - Secret Management\nAfter=network-online.target\nWants=network-online.target\n\n[Service]\nUser=vault\nGroup=vault\nExecStart=/usr/bin/vault server -config=/etc/vault/vault.hcl\nExecReload=/bin/kill -HUP $MAINPID\nRestart=on-failure\nLimitNOFILE=65536\n\n[Install]\nWantedBy=multi-user.target\n사용자변경 및 권한설정\nsudo chown root:root /etc/systemd/system/vault.service\nsudo chmod 644 /etc/systemd/system/vault.service\n\n\n기동\nsudo systemctl daemon-reload\nsudo systemctl enable vault\n```bash\nsudo systemctl start vault \nsudo systemctl status vault\n\n\n\n최초설정\nsudo vault operator init\nHTTPS와 HTTP 불일치를 해결을 위한 인자로 주어서 초기설정 시작\n sudo vault operator init -address=\"http://127.0.0.1:8200\"\n키와 토큰을 잘 저장한 후\nvault operator unseal &lt;UNSEAL_KEY&gt;\nSealed: false로 바뀐 것을 확인한 후"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Blog",
    "section": "",
    "text": "Order By\n       Default\n         \n          Title\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Author\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n\n\n\n중앙 로그관리 시스템\n\n\n\n\n\n\nELK Stack\n\n\n\nELK Stack\n\n\n\n\n\nJun 27, 2025\n\n\nBenKorea\n\n\n\n\n\n\n\n\n\n\n\n\n민감정보관리시스템 구축\n\n\n\n\n\n\nVault\n\n\n\n개인정보보호 위해 HashiCorp Vault 구축\n\n\n\n\n\nJun 18, 2025\n\n\nBenKorea\n\n\n\n\n\n\n\n\n\n\n\n\n계정관리시스템 구축\n\n\n\n\n\n\nopenLDAP\n\n\n\n개인정보보호를 위한 OpenLDAP 시스템 구축\n\n\n\n\n\nJun 24, 2024\n\n\nBenKorea\n\n\n\n\n\n\n\n\n\n\n\n\n인증시스템 구축\n\n\n\n\n\n\nAuthentication\n\n\nKeyCloak\n\n\n\n게인정보보호 위해 KeyCloak 구축\n\n\n\n\n\nJun 22, 2024\n\n\nBenKorea\n\n\n\n\n\n\n\n\n\n\n\n\n개발기록\n\n\n\n\n\n\ndeveolpment\n\n\n\n개발과정을 기록하여 나의 기억과 협업에 도움이 되고자 함\n\n\n\n\n\nJun 18, 2025\n\n\nBenKorea\n\n\n\n\n\n\n\n\n\n\n\n\n가명화\n\n\n\n\n\n\n\n\n\n\n\nJun 20, 2025\n\n\nBenKorea feat Copilot\n\n\n\n\n\n\n\n\n\n\n\n\npython 프로젝트 설정\n\n\n\n\n\n\n\n\n\n\n\nJun 18, 2025\n\n\nBenKorea\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/development/authentication/authentication.html",
    "href": "posts/development/authentication/authentication.html",
    "title": "인증시스템구축",
    "section": "",
    "text": "인증 시스템 선택\n\n개인정보보호법 준수를 위해 사용자별 권한 관리 필요\n오픈소스 Keycloak 도입 결정\n\n\n\n사용자 역할 정의\n\n관리자(nmdose-superuser):\n\n시스템 설정, 사용자 관리, 감사 기록 조회 등 모든 권한 보유\n\n일반 사용자(nmdose-user):\n\n선량 정보 조회 등 제한된 기능만 접근 가능\n\n\n\n\nkeycloak 설치\n\n인증 서버는 nmdose 시스템과 분리된 서버에 설치하는 것이 이상적이나, 개발 단계에서는 Docker를 활용해 분리된 서버를 모사함\n운영(Production) 환경에서는 별도의 데이터베이스 지정 및 HTTPS(TLS) 인증서 적용 필요\n병원 내부망(도메인 없는 사설망)에서는 공인 인증서가 아닌 “자가서명 인증서” 또는 “사내 CA 인증서”를 사용 필요하므로\n\nubuntu에 제공되는 openssl로 자가서명 인증서를 발급\n\n\n\n\n\nbash\n\nopenssl req \\\n  -x509 \\\n  -newkey rsa:2048 \\\n  -keyout mykey.key \\\n  -out mycert.crt \\\n  -days 365 \\\n  -nodes \\\n  -subj \"/C=KR/ST=Seoul/L=Seoul/O=KCCH/OU=RPythonStudy/CN=localhost\" \\\n  -addext \"subjectAltName = DNS:localhost, IP:127.0.0.1, DNS:keycloak-server\"\n\n\n업계표준에 따른 저장폴더는\n\n\n\nbash\n\nsudo mkdir -p /etc/nmdose/certs/\n\n\n\n\n\nbash\n\nsudo cp ~/projects/keycloak-server/mycert.crt /etc/nmdose/certs/server.crt\nsudo cp ~/projects/keycloak-server/mykey.key /etc/nmdose/certs/server.key\n\n\n파일의 권한에 대해서도 항상 신경써야 한다.\n\n\n\nbash\n\nsudo chmod 644 /etc/nmdose/certs/server.key\nsudo chmod 644 /etc/nmdose/certs/server.crt\n\n\n그러나 chmod 644는 보안정책에 위반되므로 vault로 동적으로 주입하는 것으로 전환해야 함.\n아래는 chmod 644에서 성공하기는 했음. 그러나 vault로 수정이 필요함.\n매뉴얼에 따르면 keycloak production mode는 3가지 설정이 필요하다. - HTTPS - hostname - TLS\n커맨드라인에서 bin/kc.[sh|bat] start –https-certificate-file=/path/to/certfile.pem –https-certificate-key-file=/path/to/keyfile.pem 명령으로 HTTPS/TLS에 필요한 certificate 파일과 key 파일의 경로를 전달한다.\n\n\n\nprojects/keycloak-server/docker-compose.yml\n\nversion: \"3.8\"\n\nservices:\n  postgres:\n    image: postgres:16\n    container_name: nmdose-postgres\n    restart: always\n    environment:\n      POSTGRES_DB: keycloak\n      POSTGRES_USER: keycloak\n      POSTGRES_PASSWORD: keycloakpass\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\n    networks:\n      - nmdose-net\n\n  keycloak:\n    image: quay.io/keycloak/keycloak:25.0.0\n    container_name: nmdose-keycloak\n    command:\n      - start\n      - --https-certificate-file=/etc/x509/https/tls.crt\n      - --https-certificate-key-file=/etc/x509/https/tls.key\n      - --db=postgres\n      - --db-url-host=postgres\n      - --db-username=keycloak\n      - --db-password=keycloakpass\n      - --db-database=keycloak\n      - --hostname=localhost\n    environment:\n      KC_HEALTH_ENABLED: \"true\"\n      KC_METRICS_ENABLED: \"true\"\n      KEYCLOAK_ADMIN: admin\n      KEYCLOAK_ADMIN_PASSWORD: adminpass\n    volumes:\n      # 인증서 마운트: 호스트 → 컨테이너\n      - /etc/nmdose/certs/server.crt:/etc/x509/https/tls.crt:ro\n      - /etc/nmdose/certs/server.key:/etc/x509/https/tls.key:ro\n    depends_on:\n      - postgres\n    ports:\n      - \"8443:8443\"\n    networks:\n      - nmdose-net\n\nvolumes:\n  postgres_data:\n\nnetworks:\n  nmdose-net:\n    driver: bridge\n\n\n\n\n\nbash\n\nsudo docker compose up -d\n\n\n\n\n\nbash\n\nsudo docker compose ps",
    "crumbs": [
      "개발기록",
      "인증시스템구축"
    ]
  },
  {
    "objectID": "posts/pseudonymize_files.html",
    "href": "posts/pseudonymize_files.html",
    "title": "가명화",
    "section": "",
    "text": "R에서도 로그레벨에 따른 출력설정이 가능하므로 이 프로젝트에서 logger chunk에서 이를 구현하였습니다. 이를 위해서는 미리 .Rprofile에 코딩하는 등의 사전준비가 필요하므로 지금은 단순히 - log_debug() - log_info() - log_warn() - log_error() 중에 하나를 선택하여 메시지를 출력함으로써 프로그램의 진행상황과 오류 메시지를 체계적으로 관리할 수 있도록 하였습니다.\n\nif (!requireNamespace(\"logger\", quietly = TRUE)) install.packages(\"logger\")\n\n# Downloading packages -------------------------------------------------------\n- Downloading logger from CRAN ...              OK [664.8 Kb in 0.99s]\nSuccessfully downloaded 1 package in 3.2 seconds.\n\nThe following package(s) will be installed:\n- logger [0.4.0]\nThese packages will be installed into \"~/projects/p31211-r450-pseudo_struct/renv/library/linux-ubuntu-noble/R-4.5/x86_64-pc-linux-gnu\".\n\n# Installing packages --------------------------------------------------------\n- Installing logger ...                         OK [built from source and cached in 3.9s]\nSuccessfully installed 1 package in 4.1 seconds.\n\nlibrary(logger)"
  },
  {
    "objectID": "posts/pseudonymize_files.html#로그설정",
    "href": "posts/pseudonymize_files.html#로그설정",
    "title": "가명화",
    "section": "",
    "text": "R에서도 로그레벨에 따른 출력설정이 가능하므로 이 프로젝트에서 logger chunk에서 이를 구현하였습니다. 이를 위해서는 미리 .Rprofile에 코딩하는 등의 사전준비가 필요하므로 지금은 단순히 - log_debug() - log_info() - log_warn() - log_error() 중에 하나를 선택하여 메시지를 출력함으로써 프로그램의 진행상황과 오류 메시지를 체계적으로 관리할 수 있도록 하였습니다.\n\nif (!requireNamespace(\"logger\", quietly = TRUE)) install.packages(\"logger\")\n\n# Downloading packages -------------------------------------------------------\n- Downloading logger from CRAN ...              OK [664.8 Kb in 0.99s]\nSuccessfully downloaded 1 package in 3.2 seconds.\n\nThe following package(s) will be installed:\n- logger [0.4.0]\nThese packages will be installed into \"~/projects/p31211-r450-pseudo_struct/renv/library/linux-ubuntu-noble/R-4.5/x86_64-pc-linux-gnu\".\n\n# Installing packages --------------------------------------------------------\n- Installing logger ...                         OK [built from source and cached in 3.9s]\nSuccessfully installed 1 package in 4.1 seconds.\n\nlibrary(logger)"
  },
  {
    "objectID": "posts/pseudonymize_files.html#파일-읽어오기",
    "href": "posts/pseudonymize_files.html#파일-읽어오기",
    "title": "가명화",
    "section": "2 파일 읽어오기",
    "text": "2 파일 읽어오기\nlist.files를 이용해서 파일이름들을 리스트로 가져오는 가장 일반적인 방식입니다. 향후 진행될 가명화를 위해서 파일이름 리스트에서 확장자를 제거한 후, register_numbers라는 문자형 벡터(character vector)로 생성합니다.\n\nfile_list &lt;- list.files(\"../data/raw\", pattern = \"\\\\.txt$\")\nregister_numbers &lt;- tools::file_path_sans_ext(file_list)\nlog_info(\"등록번호 추출 완료: {paste(register_numbers, collapse=', ')}\")"
  },
  {
    "objectID": "posts/pseudonymize_files.html#파일이름-가명화",
    "href": "posts/pseudonymize_files.html#파일이름-가명화",
    "title": "가명화",
    "section": "3 파일이름 가명화",
    "text": "3 파일이름 가명화\n본 프로젝트에서는 파일명이 등록번호로 구성되어 있다고 가정합니다. 따라서 파일명을 가명화하는 과정이 필요합니다. 가명화 방식으로는 가역적이며 일관성을 보장하는 가명화(reversible deterministic pseudonymization)를 채택하였습니다. 이를 위해 원본 형식을 유지하는 형식보존암호화(format-preserving encryption)를 적용하였으며, 미국 NIST에서 권장하는 알고리즘을 구현한 FF3 파이썬 패키지를 활용하였습니다.\n\nif (!requireNamespace(\"reticulate\", quietly = TRUE)) install.packages(\"reticulate\")\n\n# Downloading packages -------------------------------------------------------\n- Downloading reticulate from CRAN ...          OK [1.6 Mb in 0.52s]\n- Downloading RcppTOML from CRAN ...            OK [136.6 Kb in 0.49s]\nSuccessfully downloaded 2 packages in 1.8 seconds.\n\nThe following package(s) will be installed:\n- png        [0.1-8]\n- Rcpp       [1.0.14]\n- RcppTOML   [0.2.3]\n- reticulate [1.42.0]\nThese packages will be installed into \"~/projects/p31211-r450-pseudo_struct/renv/library/linux-ubuntu-noble/R-4.5/x86_64-pc-linux-gnu\".\n\n# Installing packages --------------------------------------------------------\n- Installing Rcpp ...                           OK [linked from cache]\n- Installing RcppTOML ...                       OK [built from source and cached in 17s]\n- Installing png ...                            OK [linked from cache]\n- Installing reticulate ...                     OK [built from source and cached in 32s]\nSuccessfully installed 4 packages in 50 seconds.\n\nlibrary(reticulate)\n\n# 파이썬 모듈 임포트\nff3 &lt;- import(\"ff3\")\n\n# FF3Cipher 객체 생성 (키, 트윅, 알파벳은 파이썬과 동일하게 지정)\nKEY &lt;- \"0123456789abcdef0123456789abcdef\"\nTWEAK &lt;- \"abcdef12345678\"\nALPHABET &lt;- \"0123456789\"\ncipher &lt;- ff3$FF3Cipher$withCustomAlphabet(KEY, TWEAK, ALPHABET)\n\n# 등록번호 벡터를 FF3로 가명화\npseudonym_list &lt;- sapply(register_numbers, cipher$encrypt)\nlog_info(\"가명화된 등록번호: {paste(pseudonym_list, collapse=', ')}\")\n\n# 결과 확인\nresult_df &lt;- data.frame(\n  original_id = register_numbers,\n  pseudonym = pseudonym_list,\n  stringsAsFactors = FALSE\n)"
  },
  {
    "objectID": "posts/pseudonymize_files.html#파일이름-복호화",
    "href": "posts/pseudonymize_files.html#파일이름-복호화",
    "title": "가명화",
    "section": "4 파일이름 복호화",
    "text": "4 파일이름 복호화\n\n# FF3Cipher 객체는 이미 생성되어 있다고 가정합니다.\n# (cipher &lt;- ff3$FF3Cipher$withCustomAlphabet(KEY, TWEAK, ALPHABET))\n\n# 복호화: pseudonym_list를 원본으로 되돌리기\ndecrypted_list &lt;- sapply(pseudonym_list, cipher$decrypt)\n\n# 복호화 결과 확인\nresult_df$decrypted &lt;- decrypted_list\nprint(result_df)\n\n[1] original_id decrypted  \n&lt;0 rows&gt; (or 0-length row.names)"
  },
  {
    "objectID": "posts/pseudonymize_files.html#복호화-검증",
    "href": "posts/pseudonymize_files.html#복호화-검증",
    "title": "가명화",
    "section": "5 복호화 검증",
    "text": "5 복호화 검증\n\n# 복호화 결과가 원본과 동일한지 검증\nall_equal &lt;- all(result_df$original_id == result_df$decrypted)\nif (all_equal) {\n  log_success(\"복호화 결과가 원본과 완전히 일치합니다.\")\n} else {\n  log_error(\"복호화 결과와 원본이 일치하지 않는 값이 있습니다.\")\n  print(result_df[result_df$original_id != result_df$decrypted, ])\n}"
  },
  {
    "objectID": "posts/pseudonymize_files.html#파일-내용-읽어오기",
    "href": "posts/pseudonymize_files.html#파일-내용-읽어오기",
    "title": "가명화",
    "section": "6 파일 내용 읽어오기",
    "text": "6 파일 내용 읽어오기\n이 단계에서는 가명화된 파일명과 매칭되는 원본 파일의 내용을 읽어옵니다.\n파일마다 인코딩이 다를 수 있으므로, 인코딩 자동 감지 및 변환을 함께 처리하는 것이 좋습니다.\n\nif (!requireNamespace(\"stringi\", quietly = TRUE)) install.packages(\"stringi\")\nlibrary(stringi)\n\n# 파일 경로 벡터 생성\nfile_paths &lt;- file.path(\"data/raw\", file_list)\n\n# 인코딩 감지 없이 UTF-8로 처리 (실패 시 깨질 수 있음)\nread_file_content &lt;- function(path) {\n  content &lt;- stringi::stri_read_lines(path, encoding = \"UTF-8\")  # 인코딩 고정\n  paste(content, collapse = \"\\n\")\n}\n\nfile_contents &lt;- lapply(file_paths, read_file_content)\n\n# 데이터프레임에 내용 추가\nresult_df$content &lt;- file_contents\n\n# 일부 결과 확인\nprint(result_df[, c(\"original_id\", \"pseudonym\", \"content\")])\n\n하지만 위 코드에서 encoding을 “UTF-8”로 지정하면 stringi::stri_read_lines 함수에서 오류가 발생할 수 있으므로, 인코딩을 자동 감지하도록 아래와 같이 수정해야 합니다.\n\nif (!requireNamespace(\"stringi\", quietly = TRUE)) install.packages(\"stringi\")\n\nThe following package(s) will be installed:\n- stringi [1.8.7]\nThese packages will be installed into \"~/projects/p31211-r450-pseudo_struct/renv/library/linux-ubuntu-noble/R-4.5/x86_64-pc-linux-gnu\".\n\n# Installing packages --------------------------------------------------------\n- Installing stringi ...                        OK [linked from cache]\nSuccessfully installed 1 package in 6 milliseconds.\n\nlibrary(stringi)\n\n# 파일 경로 벡터 생성\nfile_paths &lt;- file.path(\"data/raw\", file_list)\n\n# 인코딩 감지 후 해당 인코딩으로 파일 읽기 및 로그 기록 (glue 문법 사용)\nread_file_content &lt;- function(path) {\n  raw_bytes &lt;- readBin(path, what = \"raw\", n = file.info(path)$size)\n  detected &lt;- stringi::stri_enc_detect(raw_bytes)[[1]]\n  best &lt;- detected[1, ]\n  log_info(\"파일 [{path}]의 감지된 인코딩: {best$Encoding} (신뢰도: {round(best$Confidence, 2)})\")\n  content &lt;- stringi::stri_read_lines(path, encoding = best$Encoding)\n  paste(content, collapse = \"\\n\")\n}\n\nfile_contents &lt;- lapply(file_paths, read_file_content)\n\n# 데이터프레임에 내용 추가\nresult_df$content &lt;- file_contents\n\n# 총 파일 개수 로그로 출력\nlog_success(\"총 {length(file_paths)}개의 파일을 성공적으로 읽었습니다.\")"
  },
  {
    "objectID": "posts/development/secret-management.html",
    "href": "posts/development/secret-management.html",
    "title": "민감정보관리시스템 구축",
    "section": "",
    "text": "마운트에 필요한 디렉토리를 만들고\n\n\n\n\nbash\n\nsudo mkdir -p ~/projects/vault\n\n\n\n적절한 권한을 부여\n\n\n\n\nbash\n\nsudo mkdir -p ~/projects/vault/config ~/projects/vault/file ~/projects/vault/certs ~/projects/vault/logs\nsudo chown 100:100 ~/projects/vault/config ~/projects/vault/file ~/projects/vault/certs ~/projects/vault/logs\nsudo chmod 700 ~/projects/vault/config ~/projects/vault/file ~/projects/vault/certs ~/projects/vault/logs\n\n\n\n검증\n\n\n\n\nbash\n\nsudo ls -ld ~/projects/vault ~/projects/vault/config ~/projects/vault/certs ~/projects/vault/file ~/projects/vault/logs\n\n\n\n\n\n\n\n\nbash\n\nsudo openssl req \\\n  -x509 \\\n  -newkey rsa:2048 \\\n  -keyout projects/vault/certs/vault.key \\\n  -out projects/vault/certs/vault.crt \\\n  -days 14 \\\n  -nodes \\\n  -subj \"/C=KR/ST=Seoul/L=Seoul/O=KIRAMS/OU=RPythonStudy/CN=localhost\" \\\n  -addext \"subjectAltName = DNS:localhost, IP:127.0.0.1, DNS:keycloak-server, DNS:openldap-server\"\n\n\n\n컨테이너 내 vault가 사용할 수 있도록 권한설정\n\n\n\n\nbash\n\nsudo chown 100:100 ./projects/vault/certs/vault.key\n\n\n\n검증\n\n\n\n\nbash\n\nsudo ls -l projects/vault/certs\n\n\n\n\n\nbash\n\nsudo openssl x509 -in projects/vault/certs/vault.crt -noout -text | grep -E 'Subject:|DNS:|IP Address'\n\n\n\n\n\n\n\n\nbash\n\nsudo nano projects/vault/docker-compose.yml\n\n\n\n\n\ndocker-compose.yml\n\nservices:\n  vault:\n    image: hashicorp/vault:latest\n    container_name: vault\n    cap_add:\n      - IPC_LOCK\n    environment:\n      VAULT_LOCAL_CONFIG: |\n        {\n          \"storage\": {\"file\": {\"path\": \"/vault/file\"}},\n          \"listener\": [\n            {\"tcp\": { \"address\": \"0.0.0.0:8200\", \"tls_cert_file\": \"/vault/certs/vault.crt\", \"tls_key_file\": \"/vault/certs/vault.key\"}}\n          ],\n          \"default_lease_ttl\": \"168h\",\n          \"max_lease_ttl\": \"720h\",\n          \"ui\": true\n        }\n    ports:\n      - \"8200:8200\"\n    volumes:\n      - ./file:/vault/file\n      - ./certs:/vault/certs      \n    restart: unless-stopped\n    command: server",
    "crumbs": [
      "개발기록",
      "민감정보관리시스템 구축"
    ]
  },
  {
    "objectID": "posts/development/authentication.html",
    "href": "posts/development/authentication.html",
    "title": "인증시스템 구축",
    "section": "",
    "text": "0.1 인증 시스템 선택\n\n개인정보보호법 준수를 위해 사용자별 권한 관리 필요\n오픈소스 Keycloak 도입 결정\n\n\n\n0.2 사용자 역할 정의\n\n관리자(nmdose-superuser):\n\n시스템 설정, 사용자 관리, 감사 기록 조회 등 모든 권한 보유\n\n일반 사용자(nmdose-user):\n\n선량 정보 조회 등 제한된 기능만 접근 가능\n\n\n\n\n0.3 keycloak 설치\n\n인증 서버는 nmdose 시스템과 분리된 서버에 설치하는 것이 이상적이나, 개발 단계에서는 Docker를 활용해 분리된 서버를 모사함\n운영(Production) 환경에서는 별도의 데이터베이스 지정 및 HTTPS(TLS) 인증서 적용 필요\n병원 내부망(도메인 없는 사설망)에서는 공인 인증서가 아닌 “자가서명 인증서” 또는 “사내 CA 인증서”를 사용 필요하므로\n\nubuntu에 제공되는 openssl로 자가서명 인증서를 발급\n\n\n\n\n\nbash\n\nopenssl req \\\n  -x509 \\\n  -newkey rsa:2048 \\\n  -keyout /etc/shared-certs/server.key \\\n  -out /etc/shared-certs/server.crt \\\n  -days 365 \\\n  -nodes \\\n  -subj \"/C=KR/ST=Seoul/L=Seoul/O=KIRAMS/OU=RPythonStudy/CN=localhost\" \\\n  -addext \"subjectAltName = DNS:localhost, IP:127.0.0.1, DNS:keycloak-server, DNS:openldap-server\"\n\n\n업계표준에 따른 저장폴더는\n\n\n\nbash\n\nsudo mkdir -p /etc/nmdose/certs/\n\n\n\n\n\nbash\n\nsudo cp ~/projects/keycloak-server/mycert.crt /etc/nmdose/certs/server.crt\nsudo cp ~/projects/keycloak-server/mykey.key /etc/nmdose/certs/server.key\n\n\n파일의 권한에 대해서도 항상 신경써야 한다.\n\n\n\nbash\n\nsudo chmod 644 /etc/nmdose/certs/server.key\nsudo chmod 644 /etc/nmdose/certs/server.crt\n\n\n그러나 chmod 644는 보안정책에 위반되므로 vault로 동적으로 주입하는 것으로 전환해야 함.\n아래는 chmod 644에서 성공하기는 했음. 그러나 vault로 수정이 필요함.\n매뉴얼에 따르면 keycloak production mode는 3가지 설정이 필요하다. - HTTPS - hostname - TLS\n커맨드라인에서 bin/kc.[sh|bat] start –https-certificate-file=/path/to/certfile.pem –https-certificate-key-file=/path/to/keyfile.pem 명령으로 HTTPS/TLS에 필요한 certificate 파일과 key 파일의 경로를 전달한다.\n\n\n\nprojects/keycloak-server/docker-compose.yml\n\nversion: \"3.8\"\n\nservices:\n  postgres:\n    image: postgres:16\n    container_name: nmdose-postgres\n    restart: always\n    environment:\n      POSTGRES_DB: keycloak\n      POSTGRES_USER: keycloak\n      POSTGRES_PASSWORD: keycloakpass\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\n    networks:\n      - nmdose-net\n\n  keycloak:\n    image: quay.io/keycloak/keycloak:25.0.0\n    container_name: nmdose-keycloak\n    command:\n      - start\n      - --https-certificate-file=/etc/x509/https/tls.crt\n      - --https-certificate-key-file=/etc/x509/https/tls.key\n      - --db=postgres\n      - --db-url-host=postgres\n      - --db-username=keycloak\n      - --db-password=keycloakpass\n      - --db-database=keycloak\n      - --hostname=localhost\n    environment:\n      KC_HEALTH_ENABLED: \"true\"\n      KC_METRICS_ENABLED: \"true\"\n      KEYCLOAK_ADMIN: admin\n      KEYCLOAK_ADMIN_PASSWORD: adminpass\n    volumes:\n      # 인증서 마운트: 호스트 → 컨테이너\n      - /etc/nmdose/certs/server.crt:/etc/x509/https/tls.crt:ro\n      - /etc/nmdose/certs/server.key:/etc/x509/https/tls.key:ro\n    depends_on:\n      - postgres\n    ports:\n      - \"8443:8443\"\n    networks:\n      - nmdose-net\n\nvolumes:\n  postgres_data:\n\nnetworks:\n  nmdose-net:\n    driver: bridge\n\n\n\n\n\nbash\n\nsudo docker compose up -d\n\n\n\n\n\nbash\n\nsudo docker compose ps",
    "crumbs": [
      "개발기록",
      "인증시스템 구축"
    ]
  },
  {
    "objectID": "posts/development/secret-management.html#개인정보보호",
    "href": "posts/development/secret-management.html#개인정보보호",
    "title": "비밀관리시스템구축",
    "section": "",
    "text": "의무기록시스템(EMR)으로부터 추출된 의료정보는 중앙 로깅 서버에 모든 접근 및 다운로드 이력이 기록되어야 한다.\n가명화 또는 익명화 조치를 수행하는 책임자는 해당 조치의 수행 이력 및 방식에 대한 기록(log)을 남겨야 하며, 이 기록은 감사를 위해 보존되어야 한다.\n임상연구를 위해 가명화된 환자 식별자는 동일 환자의 반복 가명화 시에도 일관되게 동일한 가명 식별자로 생성되어야 하며, 이를 통해 시간대별 또는 다기관 간 데이터 통합 및 분석이 가능하도록 해야 한다.\n가명화된 정보는 적법한 원내 승인 절차(예: 연구윤리위원회(IRB) 승인 등)에 따른 요청이 있을 경우, 정당한 목적 하에 원 식별자에 대한 역추적이 가능하도록 체계가 마련되어야 한다.\n\n\n\n이 프로젝트에서는 가명화를 위해 HashCorp Vault를 사용하며, 가명화(익명화)담당자가 HashCorp Vault를 사용하여 가명화 키를 관리한다고 가정하였다.\n\n\n\n운영체제별로… 여기서는 wsl2 ubuntu\n\n\nsudo groupadd --system vault\n그룹목록을 확인\ngetent group\n\n\n\nsudo useradd --system --home /etc/vault --shell /bin/false --gid vault vault\ngetent passwd vault\n\n\n\ncurl -fsSL https://apt.releases.hashicorp.com/gpg | sudo gpg --dearmor -o /usr/share/keyrings/hashicorp-archive-keyring.gpg\n\n\n\necho \"deb [signed-by=/usr/share/keyrings/hashicorp-archive-keyring.gpg] https://apt.releases.hashicorp.com $(lsb_release -cs) main\" | sudo tee /etc/apt/sources.list.d/hashicorp.list\n\n\n\nsudo apt update\n\n\n\nsudo apt install vault\n\n\n\nvault -v\ncf) vault -version 명령은 실행되지 않으니 주의를 요한다.\n\n\n\n설정파일용\nsudo mkdir -p /etc/vault\n데이터 스토리지용\nsudo mkdir -p /var/lib/vault\n데이터 스토리지용\nsudo mkdir -p /var/log/vault\n재귀적으로 권한설정\nsudo chown -R vault:vault /etc/vault /var/lib/vault /var/log/vault\nsudo chmod 700 /etc/vault /var/lib/vault\n\n\n\n\n\n\nvault.hcl\n\n# /etc/vault/vault.hcl\n\n# 1) 스토리지 백엔드\nstorage \"file\" {\n  path = \"/var/lib/vault\"\n}\n\n# 2) 리스너 (TLS 적용 권장)\nlistener \"tcp\" {\n  address     = \"0.0.0.0:8200\"\n  tls_disable = 1            # 운영환경에서는 tls_disable = 0 과 cert/key 설정 사용\n}\n\n# 3) UI 활성화\nui = true\n\n# 4) 감사로그 (선택)\naudit \"file\" {\n  file_path = \"/var/log/vault/audit.log\"\n  log_raw   = true\n}\n\n\n설정파일에 대한 사용자 및 권한설정\nsudo chown vault:vault /etc/vault/vault.hcl\nsudo chmod 640 /etc/vault/vault.hcl\n\n\n\n/etc/systemd/system/vault.service 를 다음과 같이 작성\n[Unit]\nDescription=HashiCorp Vault - Secret Management\nAfter=network-online.target\nWants=network-online.target\n\n[Service]\nUser=vault\nGroup=vault\nExecStart=/usr/bin/vault server -config=/etc/vault/vault.hcl\nExecReload=/bin/kill -HUP $MAINPID\nRestart=on-failure\nLimitNOFILE=65536\n\n[Install]\nWantedBy=multi-user.target\n사용자변경 및 권한설정\nsudo chown root:root /etc/systemd/system/vault.service\nsudo chmod 644 /etc/systemd/system/vault.service\n\n\n\nsudo systemctl daemon-reload\nsudo systemctl enable vault\n```bash\nsudo systemctl start vault \nsudo systemctl status vault\n\n\n\n\nsudo vault operator init\nHTTPS와 HTTP 불일치를 해결을 위한 인자로 주어서 초기설정 시작\n sudo vault operator init -address=\"http://127.0.0.1:8200\"\n키와 토큰을 잘 저장한 후\nvault operator unseal &lt;UNSEAL_KEY&gt;\nSealed: false로 바뀐 것을 확인한 후",
    "crumbs": [
      "개발기록",
      "비밀관리시스템구축"
    ]
  },
  {
    "objectID": "posts/development/secret-management.html#vault-관리위원회",
    "href": "posts/development/secret-management.html#vault-관리위원회",
    "title": "민감정보관리시스템 구축",
    "section": "",
    "text": "Vault는 unseal key가 있어 필요시 이를 이용해서 root 권한으로 접속이 가능하다.\n다섯개로 이루어지 이 키들은 각각 다른 사람이 보관하는 것이 추천된다.\n따라서 이를 vault 관리위원회라 하고 각자 1개씩의 unseal key를 보관하도록 상상하였다.\n프린터를 하여 물리적인 금고에 보관하는 것을 최상위 보안방법이라 생각되지만 현실적인 타협도 고려된다.\n위원회의 구성은 의무기록의 가명화에 대한 책임이 있는 사람들로 구성하는 것이 좋을 것 같다.\n어차피 위원회가 만들어진다면 가명화정보관리위원회 또는 개인정보보호위원회라 칭하고 그 역할을 규정해도 좋을 것이다.",
    "crumbs": [
      "개발기록",
      "민감정보관리시스템 구축"
    ]
  },
  {
    "objectID": "posts/development/secret-management.html#사용자계정-분류",
    "href": "posts/development/secret-management.html#사용자계정-분류",
    "title": "민감정보관리시스템 구축",
    "section": "2 사용자계정 분류",
    "text": "2 사용자계정 분류\n\n프로젝트의 민감정보를 관리하기 위해 권한별 사용자 계정을 분류하였다.\n즉 사람을 분류한 것이 아니라 계정을 분류한 것임.\n\n\n2.1 Vault 관리자계정\n\nVault 시스템의 최상위 관리자계정 개념이다.\n계정이 따로 존재하지 않고 최초 설치시에 발급되는 root token을 사용하여 vault에 접속하면 root 권한을 가지게 된다.\n초기설정 시 감사로그 (audit log)를 남길 수 있도록 해야 한다.\n프로젝트에 종속적이지 않고 병원전체에 한명이면 된다.\n필요한 vault 사용자계정을 생성한다.\n\n\n\n2.2 Vault 사용자계정\n\nVault 관리자에 의해 생성된 사용자계정\n일단 크게 두가지 역할이 필요하다.\nKeyCloak 인증서버에 주입해야 하는 HTTPS/TLS key/certicate를 생성/보관해야 한다.\n가명화를 위한 key와 tweak를 보관해야 한다.\n\n\n\n2.3 가명화 담당자\n\n가명화담당자는 프로젝트와 독립적인 사람이 바람직하다.\n가명화를 위한 key와 tweak를 조회할 권한이 있으며, 가명화/복호화/검증을 한 후 프로젝트로 가명화된 자료를 보내주는 역할을 한다.\n\n\n\n2.4 프로젝트관리자\n\npseudo-struct 프로젝트의 총괄책임자이면서 프로젝트 설정을 관리한다.",
    "crumbs": [
      "개발기록",
      "민감정보관리시스템 구축"
    ]
  },
  {
    "objectID": "posts/development/secret-management.html#프로젝트사용자",
    "href": "posts/development/secret-management.html#프로젝트사용자",
    "title": "민감정보관리시스템 구축",
    "section": "3 ### 프로젝트사용자",
    "text": "3 ### 프로젝트사용자\n가 인증과정에 필요로 하는 로써 프로젝트를 위한 정책들은 생성하고vault root 권한을 가지지 않은 사용자\n- 사용자계정로, Vault 서버의 설정 및 관리 작업을 수행합니다.\n\n3.1 HashCorp Vault\n이 프로젝트에서는 가명화를 위해 HashCorp Vault를 사용하며, 가명화(익명화)담당자가 HashCorp Vault를 사용하여 가명화 키를 관리한다고 가정하였다.\n\n\n3.2 설치\n운영체제별로… 여기서는 wsl2 ubuntu\n\n3.2.1 시스템 그룹으로 등록\nsudo groupadd --system vault\n그룹목록을 확인\ngetent group\n\n\n3.2.2 시스템사용자로 등록\nsudo useradd --system --home /etc/vault --shell /bin/false --gid vault vault\ngetent passwd vault\n\n\n3.2.3 1. HashiCorp GPG 키 등록\ncurl -fsSL https://apt.releases.hashicorp.com/gpg | sudo gpg --dearmor -o /usr/share/keyrings/hashicorp-archive-keyring.gpg\n\n\n3.2.4 2. HashiCorp 저장소 추가\necho \"deb [signed-by=/usr/share/keyrings/hashicorp-archive-keyring.gpg] https://apt.releases.hashicorp.com $(lsb_release -cs) main\" | sudo tee /etc/apt/sources.list.d/hashicorp.list\n\n\n3.2.5 3. 패키지 정보 갱신\nsudo apt update\n\n\n3.2.6 4. Vault 설치\nsudo apt install vault\n\n\n3.2.7 설치검증\nvault -v\ncf) vault -version 명령은 실행되지 않으니 주의를 요한다.\n\n\n3.2.8 필수 디렉토리 권한설정\n설정파일용\nsudo mkdir -p /etc/vault\n데이터 스토리지용\nsudo mkdir -p /var/lib/vault\n데이터 스토리지용\nsudo mkdir -p /var/log/vault\n재귀적으로 권한설정\nsudo chown -R vault:vault /etc/vault /var/lib/vault /var/log/vault\nsudo chmod 700 /etc/vault /var/lib/vault\n\n\n3.2.9 설정파일 만들기\n\n\n\nvault.hcl\n\n# /etc/vault/vault.hcl\n\n# 1) 스토리지 백엔드\nstorage \"file\" {\n  path = \"/var/lib/vault\"\n}\n\n# 2) 리스너 (TLS 적용 권장)\nlistener \"tcp\" {\n  address     = \"0.0.0.0:8200\"\n  tls_disable = 1            # 운영환경에서는 tls_disable = 0 과 cert/key 설정 사용\n}\n\n# 3) UI 활성화\nui = true\n\n# 4) 감사로그 (선택)\naudit \"file\" {\n  file_path = \"/var/log/vault/audit.log\"\n  log_raw   = true\n}\n\n\n설정파일에 대한 사용자 및 권한설정\nsudo chown vault:vault /etc/vault/vault.hcl\nsudo chmod 640 /etc/vault/vault.hcl\n\n\n3.2.10 systemd\n/etc/systemd/system/vault.service 를 다음과 같이 작성\n[Unit]\nDescription=HashiCorp Vault - Secret Management\nAfter=network-online.target\nWants=network-online.target\n\n[Service]\nUser=vault\nGroup=vault\nExecStart=/usr/bin/vault server -config=/etc/vault/vault.hcl\nExecReload=/bin/kill -HUP $MAINPID\nRestart=on-failure\nLimitNOFILE=65536\n\n[Install]\nWantedBy=multi-user.target\n사용자변경 및 권한설정\nsudo chown root:root /etc/systemd/system/vault.service\nsudo chmod 644 /etc/systemd/system/vault.service\n\n\n3.2.11 기동\nsudo systemctl daemon-reload\nsudo systemctl enable vault\n```bash\nsudo systemctl start vault \nsudo systemctl status vault\n\n\n\n3.3 최초설정\nsudo vault operator init\nHTTPS와 HTTP 불일치를 해결을 위한 인자로 주어서 초기설정 시작\n sudo vault operator init -address=\"http://127.0.0.1:8200\"\n키와 토큰을 잘 저장한 후\nvault operator unseal &lt;UNSEAL_KEY&gt;\nSealed: false로 바뀐 것을 확인한 후",
    "crumbs": [
      "개발기록",
      "민감정보관리시스템 구축"
    ]
  },
  {
    "objectID": "posts/development/account-management.html",
    "href": "posts/development/account-management.html",
    "title": "계정관리시스템 구축",
    "section": "",
    "text": "openLDAP\n병원과의 연계가 불투명하므로 지금은 도커로 구현"
  },
  {
    "objectID": "posts/development/account-management.html#계정관리시스템-선택",
    "href": "posts/development/account-management.html#계정관리시스템-선택",
    "title": "계정관리시스템 구축",
    "section": "",
    "text": "openLDAP\n병원과의 연계가 불투명하므로 지금은 도커로 구현"
  },
  {
    "objectID": "posts/development/account-management.html#도커로-설치",
    "href": "posts/development/account-management.html#도커로-설치",
    "title": "계정관리시스템 구축",
    "section": "3 도커로 설치",
    "text": "3 도커로 설치\n\n\n\nbash\n\nsudo mkdir openldap\ncd openldap\nsudo mkdir ldap-data\nsudo mkdir ldap-config\n\n\n\n\n\ndocker-compose.yml\n\nservices:\n  openldap:\n    image: osixia/openldap:1.5.0\n    environment:\n      - LDAP_ORGANISATION=MyCompany\n      - LDAP_DOMAIN=mycompany.com\n      - LDAP_ADMIN_PASSWORD=adminpassword\n      - LDAP_TLS_CRT_FILENAME=ldap.crt\n      - LDAP_TLS_KEY_FILENAME=ldap.key\n      - LDAP_TLS_CA_CRT_FILENAME=ca.crt\n      - LDAP_TLS=true\n    ports:\n      - \"389:389\"\n      - \"636:636\"\n    volumes:\n      - ./ldap-data:/var/lib/ldap\n      - ./ldap-config:/etc/ldap/slapd.d\n      - /etc/nmdose/certs:/container/service/slapd/assets/certs"
  },
  {
    "objectID": "posts/development/secret-management.html#민감정보관리시스템-선택",
    "href": "posts/development/secret-management.html#민감정보관리시스템-선택",
    "title": "민감정보관리시스템 구축",
    "section": "",
    "text": "HashCorp Vault 무료 오픈소스로 진행",
    "crumbs": [
      "개발기록",
      "민감정보관리시스템 구축"
    ]
  },
  {
    "objectID": "posts/development/secret-management.html#vault-설치",
    "href": "posts/development/secret-management.html#vault-설치",
    "title": "민감정보관리시스템 구축",
    "section": "2 vault 설치",
    "text": "2 vault 설치\n\n도커 컨테이너로 진행\n\n\n2.1 디렉토리 생성\n\n마운트에 필요한 디렉토리를 만들고 권한을 vault 컨테이너에게 부여\n\n\n\n\nbash\n\nsudo mkdir -p ~/projects/vault\n\n\n\n\n\nbash\n\nsudo mkdir -p ~/projects/vault/config ~/projects/vault/file ~/projects/vault/tls ~/projects/vault/logs\nsudo chown 100:100 ~/projects/vault/config ~/projects/vault/file ~/projects/vault/tls ~/projects/vault/logs\nsudo chmod 700 ~/projects/vault/config ~/projects/vault/file ~/projects/vault/tls ~/projects/vault/logs\n\n\n\n검증\n\n\n\n\nbash\n\nsudo ls -ld ~/projects/vault ~/projects/vault/config ~/projects/vault/tls ~/projects/vault/file ~/projects/vault/logs\n\n\n\n\n2.2 config.hcl 작성\n\n\n\nconfig.hcl\n\n## Vault 운영모드 기본 config.hcl 예시\n\n# 1. HTTP(S) Listener 설정 (운영환경: 반드시 TLS 활성화)\nlistener \"tcp\" {\n  address       = \"0.0.0.0:8200\"               # 모든 네트워크에서 수신\n  tls_cert_file = \"/vault/tls/vault.crt\"       # 볼륨 마운트된 인증서\n  tls_key_file  = \"/vault/tls/vault.key\"       # 볼륨 마운트된 키\n  # tls_min_version = \"tls12\"                  # 필요시 최소 TLS 버전 강제\n}\n\n# 2. 스토리지 백엔드 설정 (단일 서버: file, 클러스터: raft 등)\nstorage \"file\" {\n  path = \"/vault/file\"\n}\n# storage \"raft\" {\n#   path    = \"/vault/raft\"\n#   node_id = \"vault-1\"\n# }\n# (필요시 클러스터, Consul, DynamoDB 등도 지원)\n\n# 3. UI 활성화\nui = true\n\n# 4. API 접근제어 (예시)\n# api_addr = \"https://vault.myorg.com:8200\"\n# cluster_addr = \"https://vault.myorg.com:8201\"\n\n# 5. 로그 등 고급 옵션 예시\n# log_level = \"info\"\n\n# 6. (옵션) Audit log\n# audit {\n#   file_path = \"/vault/logs/audit.log\"\n# }\n\n\n\n\n2.3 1회용 인증서만들기\n\n\n\nbash\n\nsudo openssl req \\\n  -x509 \\\n  -newkey rsa:2048 \\\n  -keyout projects/vault/tls/server.key \\\n  -out projects/vault/tls/server.crt \\\n  -days 14 \\\n  -nodes \\\n  -subj \"/C=KR/ST=Seoul/L=Seoul/O=KIRAMS/OU=RPythonStudy/CN=localhost\" \\\n  -addext \"subjectAltName = DNS:localhost, IP:127.0.0.1, DNS:keycloak-server, DNS:openldap-server\"\n\n\n\n검증\n\n\n\n\nbash\n\nsudo ls -l projects/vault/tls\n\n\n\n\n\nbash\n\nsudo openssl x509 -in projects/vault/tls/server.crt -noout -text | grep -E 'Subject:|DNS:|IP Address'\n\n\n\n\n2.4 docker-compose.yml 작성\n\n\n\ndocker-compose.yml\n\nservices:\n  vault:\n    image: hashicorp/vault:latest\n    container_name: vault\n    cap_add:\n      - IPC_LOCK\n    ports:\n      - \"8200:8200\"\n    volumes:\n      - ./config:/vault/config\n      - ./file:/vault/file\n      - ./tls:/vault/tls\n    command: server -config=/vault/config/config.hcl\n    restart: unless-stopped",
    "crumbs": [
      "개발기록",
      "민감정보관리시스템 구축"
    ]
  },
  {
    "objectID": "posts/development/secret-management.html#vault-정책계정목적-매트릭스-예시",
    "href": "posts/development/secret-management.html#vault-정책계정목적-매트릭스-예시",
    "title": "민감정보관리시스템 구축",
    "section": "2 Vault 정책/계정/목적 매트릭스 예시",
    "text": "2 Vault 정책/계정/목적 매트릭스 예시\n\nvault\n\n\n\n\n\n\n\n\n\n정책명(policy)\n계정명(entity/role)\n목적/설명\n\n\n\n\nsvc-nmdose-prod-policy\nsvc-nmdose-prod\nnmdose 운영서비스가 운영 비밀/인증서를 읽기 위해 사용\n\n\nsvc-pseudo_struct-prod-policy\nsvc-pseudo_struct-prod\npseudo_struct 운영서비스가 운영 비밀/인증서를 읽기 위해 사용\n\n\nsvc-openldap-prod-policy\nsvc-openldap-prod\nOpenLDAP 운영서비스의 비밀/인증서 접근\n\n\nsvc-keycloak-prod-policy\nsvc-keycloak-prod\nKeycloak 운영서비스의 비밀/인증서 접근\n\n\nsvc-db-prod-policy\nsvc-db-prod\nDB 접속 정보 등 운영환경 비밀 접근\n\n\nsvc-kibana-prod-policy\nsvc-kibana-prod\nKibana(감사 시스템) 운영환경 비밀 접근\n\n\nsvc-dashboard-prod-policy\nsvc-dashboard-prod\n대시보드/통계 운영환경 비밀 접근\n\n\nsvc-nmdose-dev-policy\nsvc-nmdose-dev\nnmdose 개발환경 비밀/인증서 접근\n\n\nsvc-pseudo_struct-dev-policy\nsvc-pseudo_struct-dev\npseudo_struct 개발환경 비밀/인증서 접근\n\n\nsvc-openldap-dev-policy\nsvc-openldap-dev\nOpenLDAP 개발환경 비밀/인증서 접근\n\n\nsvc-keycloak-dev-policy\nsvc-keycloak-dev\nKeycloak 개발환경 비밀/인증서 접근\n\n\nsvc-db-dev-policy\nsvc-db-dev\nDB 개발환경 비밀 접근\n\n\nsvc-kibana-dev-policy\nsvc-kibana-dev\nKibana 개발환경 비밀 접근\n\n\nsvc-dashboard-dev-policy\nsvc-dashboard-dev\n대시보드 개발환경 비밀 접근\n\n\nsvc-nmdose-stg-policy\nsvc-nmdose-stg\nnmdose 스테이징(테스트) 비밀/인증서 접근\n\n\nsvc-pseudo_struct-stg-policy\nsvc-pseudo_struct-stg\npseudo_struct 스테이징(테스트) 비밀/인증서 접근\n\n\nsvc-openldap-stg-policy\nsvc-openldap-stg\nOpenLDAP 스테이징(테스트) 비밀/인증서 접근\n\n\nsvc-keycloak-stg-policy\nsvc-keycloak-stg\nKeycloak 스테이징(테스트) 비밀/인증서 접근\n\n\nsvc-db-stg-policy\nsvc-db-stg\nDB 스테이징(테스트) 비밀 접근\n\n\nsvc-kibana-stg-policy\nsvc-kibana-stg\nKibana 스테이징(테스트) 비밀 접근\n\n\nsvc-dashboard-stg-policy\nsvc-dashboard-stg\n대시보드 스테이징(테스트) 비밀 접근\n\n\nvault-admin-policy\nvault-admin\nVault 전체 관리, 정책/계정/시스템 설정\n\n\nvault-audit-policy\nvault-audit\nVault 감사(audit) 로그 열람\n\n\nkey-admin-policy\nkey-admin\n전체 인증서/키 관리, PKI 엔진 전담\n\n\npseudo-key-admin-policy\npseudo-key-admin\n가명화키(암복호화) 생성·관리, 로테이션 등\n\n\nldap-secret-admin-policy\nldap-secret-admin\nOpenLDAP 비밀/인증서 생성·관리\n\n\nkeycloak-secret-admin-policy\nkeycloak-secret-admin\nKeycloak 비밀/인증서 생성·관리\n\n\ndb-secret-admin-policy\ndb-secret-admin\nDB 비밀/인증서 생성·관리",
    "crumbs": [
      "개발기록",
      "민감정보관리시스템 구축"
    ]
  },
  {
    "objectID": "posts/development/account-management.html#자가서명-인증서",
    "href": "posts/development/account-management.html#자가서명-인증서",
    "title": "계정관리시스템 구축",
    "section": "2 자가서명 인증서",
    "text": "2 자가서명 인증서\n\nopenLDAP 서버와의 통신은 HTTPS/TLS 암호화를 적용하여 안전하게 보호해야 합니다.\nopenssl로 인증서와 키를 발급하기 전에, 해당 파일들을 저장할 디렉터리를 생성\n보안을 위해 소유주와 그룹을 root로 제한하고 root만 rwx 되도록 700으로 권한제한\n\n\n\n\nbash\n\nsudo mkdir -p /etc/shared-certs\nsudo chown root:root  /etc/shared-certs\nsudo chmod 700        /etc/shared-certs\n\n\n\n검증은\n\n\n\n\nbash\n\nls -ld /etc/shared-certs\n\n\n\nopenssl를 sudo 권한으로 실행하여 인증서와 키를 발급합니다.\n\n\n\n\nbash\n\nsudo openssl req \\\n  -x509 \\\n  -newkey rsa:2048 \\\n  -keyout /etc/shared-certs/server.key \\\n  -out /etc/shared-certs/server.crt \\\n  -days 365 \\\n  -nodes \\\n  -subj \"/C=KR/ST=Seoul/L=Seoul/O=KIRAMS/OU=RPythonStudy/CN=localhost\" \\\n  -addext \"subjectAltName = DNS:localhost, IP:127.0.0.1, DNS:keycloak-server, DNS:openldap-server\"\n\n\n\n아래의 실행명령으로 파일이 존재하는지 검증하고\n\n\n\n\nbash\n\nsudo ls -l /etc/shared-certs\n\n\n\n아래의 실행명령으로 crt 파일의 일부 내용을 조회해 봅니다.\n\n\n\n\nbash\n\nsudo openssl x509 -in /etc/shared-certs/server.crt -noout -text | grep -E 'Subject:|DNS:|IP Address'\n\n\n\n생성 후 파일 권한이 600이나 644가 아니라면 이를 각각 설정합니다.\n\n\n\n\nbash\n\nsudo chmod 600 /etc/shared-certs/server.key\nsudo chmod 644 /etc/shared-certs/server.crt"
  },
  {
    "objectID": "posts/development/secret-management.html#vault-docker-deployment",
    "href": "posts/development/secret-management.html#vault-docker-deployment",
    "title": "민감정보관리시스템 구축",
    "section": "",
    "text": "마운트에 필요한 디렉토리를 만들고\n\n\n\n\nbash\n\nsudo mkdir -p ~/projects/vault\n\n\n\n적절한 권한을 부여\n\n\n\n\nbash\n\nsudo mkdir -p ~/projects/vault/config ~/projects/vault/file ~/projects/vault/certs ~/projects/vault/logs\nsudo chown 100:100 ~/projects/vault/config ~/projects/vault/file ~/projects/vault/certs ~/projects/vault/logs\nsudo chmod 700 ~/projects/vault/config ~/projects/vault/file ~/projects/vault/certs ~/projects/vault/logs\n\n\n\n검증\n\n\n\n\nbash\n\nsudo ls -ld ~/projects/vault ~/projects/vault/config ~/projects/vault/certs ~/projects/vault/file ~/projects/vault/logs\n\n\n\n\n\n\n\n\nbash\n\nsudo openssl req \\\n  -x509 \\\n  -newkey rsa:2048 \\\n  -keyout projects/vault/certs/vault.key \\\n  -out projects/vault/certs/vault.crt \\\n  -days 14 \\\n  -nodes \\\n  -subj \"/C=KR/ST=Seoul/L=Seoul/O=KIRAMS/OU=RPythonStudy/CN=localhost\" \\\n  -addext \"subjectAltName = DNS:localhost, IP:127.0.0.1, DNS:keycloak-server, DNS:openldap-server\"\n\n\n\n컨테이너 내 vault가 사용할 수 있도록 권한설정\n\n\n\n\nbash\n\nsudo chown 100:100 ./projects/vault/certs/vault.key\n\n\n\n검증\n\n\n\n\nbash\n\nsudo ls -l projects/vault/certs\n\n\n\n\n\nbash\n\nsudo openssl x509 -in projects/vault/certs/vault.crt -noout -text | grep -E 'Subject:|DNS:|IP Address'\n\n\n\n\n\n\n\n\nbash\n\nsudo nano projects/vault/docker-compose.yml\n\n\n\n\n\ndocker-compose.yml\n\nservices:\n  vault:\n    image: hashicorp/vault:latest\n    container_name: vault\n    cap_add:\n      - IPC_LOCK\n    environment:\n      VAULT_LOCAL_CONFIG: |\n        {\n          \"storage\": {\"file\": {\"path\": \"/vault/file\"}},\n          \"listener\": [\n            {\"tcp\": { \"address\": \"0.0.0.0:8200\", \"tls_cert_file\": \"/vault/certs/vault.crt\", \"tls_key_file\": \"/vault/certs/vault.key\"}}\n          ],\n          \"default_lease_ttl\": \"168h\",\n          \"max_lease_ttl\": \"720h\",\n          \"ui\": true\n        }\n    ports:\n      - \"8200:8200\"\n    volumes:\n      - ./file:/vault/file\n      - ./certs:/vault/certs      \n    restart: unless-stopped\n    command: server",
    "crumbs": [
      "개발기록",
      "민감정보관리시스템 구축"
    ]
  },
  {
    "objectID": "posts/dev/elkstack.html",
    "href": "posts/dev/elkstack.html",
    "title": "중앙 로그관리 시스템",
    "section": "",
    "text": "bash\n\nsudo mkdir -p ~/projects/elk\n\n\n\n\n\nbash\n\nsudo mkdir -p ~/projects/elk/esdata ~/projects/elk/logstash ~/projects/elk/logstash/pipline\n\n\n\n검증\n\n\n\n\nbash\n\nsudo ls -ld ~/projects/elk ~/projects/elk/esdata ~/projects/elk/logstash ~/projects/elk/logstash/pipline\n\n\n\n\n\n\n\n\nbash\n\nsudo nano projects/elk/docker-compose.yml\n\n\n\n\n\ndocker-compose.yml\n\nservices:\n  elasticsearch:\n    image: docker.elastic.co/elasticsearch/elasticsearch:8.14.0\n    container_name: elasticsearch\n    environment:\n      - discovery.type=single-node\n      - ES_JAVA_OPTS=-Xms1g -Xmx1g   # (필요시 메모리 조정)\n    ulimits:\n      memlock:\n        soft: -1\n        hard: -1\n    volumes:\n      - ./esdata:/usr/share/elasticsearch/data\n    ports:\n      - \"9200:9200\"\n    networks:\n      - elk\n\n  logstash:\n    image: docker.elastic.co/logstash/logstash:8.14.0\n    container_name: logstash\n    environment:\n      - LS_JAVA_OPTS=-Xms512m -Xmx512m\n    volumes:\n      - ./logstash/pipeline:/usr/share/logstash/pipeline\n    ports:\n      - \"5044:5044\"      # Filebeat/Log 수신용\n      - \"9600:9600\"      # Logstash API\n    depends_on:\n      - elasticsearch\n    networks:\n      - elk\n\n  kibana:\n    image: docker.elastic.co/kibana/kibana:8.14.0\n    container_name: kibana\n    environment:\n      - ELASTICSEARCH_HOSTS=http://elasticsearch:9200\n    ports:\n      - \"5601:5601\"\n    depends_on:\n      - elasticsearch\n    networks:\n      - elk\n\nnetworks:\n  elk:\n    driver: bridge"
  },
  {
    "objectID": "posts/dev/elkstack.html#elk-stack-설치",
    "href": "posts/dev/elkstack.html#elk-stack-설치",
    "title": "중앙 로그관리 시스템",
    "section": "",
    "text": "bash\n\nsudo mkdir -p ~/projects/elk\n\n\n\n\n\nbash\n\nsudo mkdir -p ~/projects/elk/esdata ~/projects/elk/logstash ~/projects/elk/logstash/pipline\n\n\n\n검증\n\n\n\n\nbash\n\nsudo ls -ld ~/projects/elk ~/projects/elk/esdata ~/projects/elk/logstash ~/projects/elk/logstash/pipline\n\n\n\n\n\n\n\n\nbash\n\nsudo nano projects/elk/docker-compose.yml\n\n\n\n\n\ndocker-compose.yml\n\nservices:\n  elasticsearch:\n    image: docker.elastic.co/elasticsearch/elasticsearch:8.14.0\n    container_name: elasticsearch\n    environment:\n      - discovery.type=single-node\n      - ES_JAVA_OPTS=-Xms1g -Xmx1g   # (필요시 메모리 조정)\n    ulimits:\n      memlock:\n        soft: -1\n        hard: -1\n    volumes:\n      - ./esdata:/usr/share/elasticsearch/data\n    ports:\n      - \"9200:9200\"\n    networks:\n      - elk\n\n  logstash:\n    image: docker.elastic.co/logstash/logstash:8.14.0\n    container_name: logstash\n    environment:\n      - LS_JAVA_OPTS=-Xms512m -Xmx512m\n    volumes:\n      - ./logstash/pipeline:/usr/share/logstash/pipeline\n    ports:\n      - \"5044:5044\"      # Filebeat/Log 수신용\n      - \"9600:9600\"      # Logstash API\n    depends_on:\n      - elasticsearch\n    networks:\n      - elk\n\n  kibana:\n    image: docker.elastic.co/kibana/kibana:8.14.0\n    container_name: kibana\n    environment:\n      - ELASTICSEARCH_HOSTS=http://elasticsearch:9200\n    ports:\n      - \"5601:5601\"\n    depends_on:\n      - elasticsearch\n    networks:\n      - elk\n\nnetworks:\n  elk:\n    driver: bridge"
  },
  {
    "objectID": "posts/dev/keycloak.html",
    "href": "posts/dev/keycloak.html",
    "title": "인증시스템 구축",
    "section": "",
    "text": "0.1 인증 시스템 선택\n\n개인정보보호법 준수를 위해 사용자별 권한 관리 필요\n오픈소스 Keycloak 도입 결정\n\n\n\n0.2 사용자 역할 정의\n\n관리자(nmdose-superuser):\n\n시스템 설정, 사용자 관리, 감사 기록 조회 등 모든 권한 보유\n\n일반 사용자(nmdose-user):\n\n선량 정보 조회 등 제한된 기능만 접근 가능\n\n\n\n\n0.3 keycloak 설치\n\n인증 서버는 nmdose 시스템과 분리된 서버에 설치하는 것이 이상적이나, 개발 단계에서는 Docker를 활용해 분리된 서버를 모사함\n운영(Production) 환경에서는 별도의 데이터베이스 지정 및 HTTPS(TLS) 인증서 적용 필요\n병원 내부망(도메인 없는 사설망)에서는 공인 인증서가 아닌 “자가서명 인증서” 또는 “사내 CA 인증서”를 사용 필요하므로\n\nubuntu에 제공되는 openssl로 자가서명 인증서를 발급\n\n\n\n\n\nbash\n\nopenssl req \\\n  -x509 \\\n  -newkey rsa:2048 \\\n  -keyout /etc/shared-certs/server.key \\\n  -out /etc/shared-certs/server.crt \\\n  -days 365 \\\n  -nodes \\\n  -subj \"/C=KR/ST=Seoul/L=Seoul/O=KIRAMS/OU=RPythonStudy/CN=localhost\" \\\n  -addext \"subjectAltName = DNS:localhost, IP:127.0.0.1, DNS:keycloak-server, DNS:openldap-server\"\n\n\n업계표준에 따른 저장폴더는\n\n\n\nbash\n\nsudo mkdir -p /etc/nmdose/certs/\n\n\n\n\n\nbash\n\nsudo cp ~/projects/keycloak-server/mycert.crt /etc/nmdose/certs/server.crt\nsudo cp ~/projects/keycloak-server/mykey.key /etc/nmdose/certs/server.key\n\n\n파일의 권한에 대해서도 항상 신경써야 한다.\n\n\n\nbash\n\nsudo chmod 644 /etc/nmdose/certs/server.key\nsudo chmod 644 /etc/nmdose/certs/server.crt\n\n\n그러나 chmod 644는 보안정책에 위반되므로 vault로 동적으로 주입하는 것으로 전환해야 함.\n아래는 chmod 644에서 성공하기는 했음. 그러나 vault로 수정이 필요함.\n매뉴얼에 따르면 keycloak production mode는 3가지 설정이 필요하다. - HTTPS - hostname - TLS\n커맨드라인에서 bin/kc.[sh|bat] start –https-certificate-file=/path/to/certfile.pem –https-certificate-key-file=/path/to/keyfile.pem 명령으로 HTTPS/TLS에 필요한 certificate 파일과 key 파일의 경로를 전달한다.\n\n\n\nprojects/keycloak-server/docker-compose.yml\n\nversion: \"3.8\"\n\nservices:\n  postgres:\n    image: postgres:16\n    container_name: nmdose-postgres\n    restart: always\n    environment:\n      POSTGRES_DB: keycloak\n      POSTGRES_USER: keycloak\n      POSTGRES_PASSWORD: keycloakpass\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\n    networks:\n      - nmdose-net\n\n  keycloak:\n    image: quay.io/keycloak/keycloak:25.0.0\n    container_name: nmdose-keycloak\n    command:\n      - start\n      - --https-certificate-file=/etc/x509/https/tls.crt\n      - --https-certificate-key-file=/etc/x509/https/tls.key\n      - --db=postgres\n      - --db-url-host=postgres\n      - --db-username=keycloak\n      - --db-password=keycloakpass\n      - --db-database=keycloak\n      - --hostname=localhost\n    environment:\n      KC_HEALTH_ENABLED: \"true\"\n      KC_METRICS_ENABLED: \"true\"\n      KEYCLOAK_ADMIN: admin\n      KEYCLOAK_ADMIN_PASSWORD: adminpass\n    volumes:\n      # 인증서 마운트: 호스트 → 컨테이너\n      - /etc/nmdose/certs/server.crt:/etc/x509/https/tls.crt:ro\n      - /etc/nmdose/certs/server.key:/etc/x509/https/tls.key:ro\n    depends_on:\n      - postgres\n    ports:\n      - \"8443:8443\"\n    networks:\n      - nmdose-net\n\nvolumes:\n  postgres_data:\n\nnetworks:\n  nmdose-net:\n    driver: bridge\n\n\n\n\n\nbash\n\nsudo docker compose up -d\n\n\n\n\n\nbash\n\nsudo docker compose ps"
  },
  {
    "objectID": "posts/dev/ldap.html",
    "href": "posts/dev/ldap.html",
    "title": "계정관리시스템 구축",
    "section": "",
    "text": "openLDAP\n병원과의 연계가 불투명하므로 지금은 도커로 구현"
  },
  {
    "objectID": "posts/dev/ldap.html#계정관리시스템-선택",
    "href": "posts/dev/ldap.html#계정관리시스템-선택",
    "title": "계정관리시스템 구축",
    "section": "",
    "text": "openLDAP\n병원과의 연계가 불투명하므로 지금은 도커로 구현"
  },
  {
    "objectID": "posts/dev/ldap.html#자가서명-인증서",
    "href": "posts/dev/ldap.html#자가서명-인증서",
    "title": "계정관리시스템 구축",
    "section": "2 자가서명 인증서",
    "text": "2 자가서명 인증서\n\nopenLDAP 서버와의 통신은 HTTPS/TLS 암호화를 적용하여 안전하게 보호해야 합니다.\nopenssl로 인증서와 키를 발급하기 전에, 해당 파일들을 저장할 디렉터리를 생성\n보안을 위해 소유주와 그룹을 root로 제한하고 root만 rwx 되도록 700으로 권한제한\n\n\n\n\nbash\n\nsudo mkdir -p /etc/shared-certs\nsudo chown root:root  /etc/shared-certs\nsudo chmod 700        /etc/shared-certs\n\n\n\n검증은\n\n\n\n\nbash\n\nls -ld /etc/shared-certs\n\n\n\nopenssl를 sudo 권한으로 실행하여 인증서와 키를 발급합니다.\n\n\n\n\nbash\n\nsudo openssl req \\\n  -x509 \\\n  -newkey rsa:2048 \\\n  -keyout /etc/shared-certs/server.key \\\n  -out /etc/shared-certs/server.crt \\\n  -days 365 \\\n  -nodes \\\n  -subj \"/C=KR/ST=Seoul/L=Seoul/O=KIRAMS/OU=RPythonStudy/CN=localhost\" \\\n  -addext \"subjectAltName = DNS:localhost, IP:127.0.0.1, DNS:keycloak-server, DNS:openldap-server\"\n\n\n\n아래의 실행명령으로 파일이 존재하는지 검증하고\n\n\n\n\nbash\n\nsudo ls -l /etc/shared-certs\n\n\n\n아래의 실행명령으로 crt 파일의 일부 내용을 조회해 봅니다.\n\n\n\n\nbash\n\nsudo openssl x509 -in /etc/shared-certs/server.crt -noout -text | grep -E 'Subject:|DNS:|IP Address'\n\n\n\n생성 후 파일 권한이 600이나 644가 아니라면 이를 각각 설정합니다.\n\n\n\n\nbash\n\nsudo chmod 600 /etc/shared-certs/server.key\nsudo chmod 644 /etc/shared-certs/server.crt"
  },
  {
    "objectID": "posts/dev/ldap.html#도커로-설치",
    "href": "posts/dev/ldap.html#도커로-설치",
    "title": "계정관리시스템 구축",
    "section": "3 도커로 설치",
    "text": "3 도커로 설치\n\n\n\nbash\n\nsudo mkdir openldap\ncd openldap\nsudo mkdir ldap-data\nsudo mkdir ldap-config\n\n\n\n\n\ndocker-compose.yml\n\nservices:\n  openldap:\n    image: osixia/openldap:1.5.0\n    environment:\n      - LDAP_ORGANISATION=MyCompany\n      - LDAP_DOMAIN=mycompany.com\n      - LDAP_ADMIN_PASSWORD=adminpassword\n      - LDAP_TLS_CRT_FILENAME=ldap.crt\n      - LDAP_TLS_KEY_FILENAME=ldap.key\n      - LDAP_TLS_CA_CRT_FILENAME=ca.crt\n      - LDAP_TLS=true\n    ports:\n      - \"389:389\"\n      - \"636:636\"\n    volumes:\n      - ./ldap-data:/var/lib/ldap\n      - ./ldap-config:/etc/ldap/slapd.d\n      - /etc/nmdose/certs:/container/service/slapd/assets/certs"
  },
  {
    "objectID": "posts/dev/vault.html",
    "href": "posts/dev/vault.html",
    "title": "민감정보관리시스템 구축",
    "section": "",
    "text": "마운트에 필요한 디렉토리를 만들고\n\n\n\n\nbash\n\nsudo mkdir -p ~/projects/vault\n\n\n\n적절한 권한을 부여\n\n\n\n\nbash\n\nsudo mkdir -p ~/projects/vault/config ~/projects/vault/file ~/projects/vault/certs ~/projects/vault/logs\nsudo chown 100:100 ~/projects/vault/config ~/projects/vault/file ~/projects/vault/certs ~/projects/vault/logs\nsudo chmod 700 ~/projects/vault/config ~/projects/vault/file ~/projects/vault/certs ~/projects/vault/logs\n\n\n\n검증\n\n\n\n\nbash\n\nsudo ls -ld ~/projects/vault ~/projects/vault/config ~/projects/vault/certs ~/projects/vault/file ~/projects/vault/logs\n\n\n\n\n\n\n\n\nbash\n\nsudo openssl req \\\n  -x509 \\\n  -newkey rsa:2048 \\\n  -keyout projects/vault/certs/vault.key \\\n  -out projects/vault/certs/vault.crt \\\n  -days 14 \\\n  -nodes \\\n  -subj \"/C=KR/ST=Seoul/L=Seoul/O=KIRAMS/OU=RPythonStudy/CN=localhost\" \\\n  -addext \"subjectAltName = DNS:localhost, IP:127.0.0.1, DNS:keycloak-server, DNS:openldap-server\"\n\n\n\n컨테이너 내 vault가 사용할 수 있도록 권한설정\n\n\n\n\nbash\n\nsudo chown 100:100 ./projects/vault/certs/vault.key\n\n\n\n검증\n\n\n\n\nbash\n\nsudo ls -l projects/vault/certs\n\n\n\n\n\nbash\n\nsudo openssl x509 -in projects/vault/certs/vault.crt -noout -text | grep -E 'Subject:|DNS:|IP Address'\n\n\n\n\n\n\n\n\nbash\n\nsudo nano projects/vault/docker-compose.yml\n\n\n\n\n\ndocker-compose.yml\n\nservices:\n  vault:\n    image: hashicorp/vault:latest\n    container_name: vault\n    cap_add:\n      - IPC_LOCK\n    environment:\n      VAULT_LOCAL_CONFIG: |\n        {\n          \"storage\": {\"file\": {\"path\": \"/vault/file\"}},\n          \"listener\": [\n            {\"tcp\": { \"address\": \"0.0.0.0:8200\", \"tls_cert_file\": \"/vault/certs/vault.crt\", \"tls_key_file\": \"/vault/certs/vault.key\"}}\n          ],\n          \"default_lease_ttl\": \"168h\",\n          \"max_lease_ttl\": \"720h\",\n          \"ui\": true\n        }\n      VAULT_API_ADDR: \"https://vault:8200\"   # &lt;--- 이 줄만 추가\n    ports:\n      - \"8200:8200\"\n    volumes:\n      - ./file:/vault/file\n      - ./certs:/vault/certs      \n    restart: unless-stopped\n    command: server\n\n\n\n검증\n\n\n\n\nbash\n\ndocker exec -it vault env | grep VAULT_API_ADDR"
  },
  {
    "objectID": "posts/dev/vault.html#vault-docker-deployment",
    "href": "posts/dev/vault.html#vault-docker-deployment",
    "title": "민감정보관리시스템 구축",
    "section": "",
    "text": "마운트에 필요한 디렉토리를 만들고\n\n\n\n\nbash\n\nsudo mkdir -p ~/projects/vault\n\n\n\n적절한 권한을 부여\n\n\n\n\nbash\n\nsudo mkdir -p ~/projects/vault/config ~/projects/vault/file ~/projects/vault/certs ~/projects/vault/logs\nsudo chown 100:100 ~/projects/vault/config ~/projects/vault/file ~/projects/vault/certs ~/projects/vault/logs\nsudo chmod 700 ~/projects/vault/config ~/projects/vault/file ~/projects/vault/certs ~/projects/vault/logs\n\n\n\n검증\n\n\n\n\nbash\n\nsudo ls -ld ~/projects/vault ~/projects/vault/config ~/projects/vault/certs ~/projects/vault/file ~/projects/vault/logs\n\n\n\n\n\n\n\n\nbash\n\nsudo openssl req \\\n  -x509 \\\n  -newkey rsa:2048 \\\n  -keyout projects/vault/certs/vault.key \\\n  -out projects/vault/certs/vault.crt \\\n  -days 14 \\\n  -nodes \\\n  -subj \"/C=KR/ST=Seoul/L=Seoul/O=KIRAMS/OU=RPythonStudy/CN=localhost\" \\\n  -addext \"subjectAltName = DNS:localhost, IP:127.0.0.1, DNS:keycloak-server, DNS:openldap-server\"\n\n\n\n컨테이너 내 vault가 사용할 수 있도록 권한설정\n\n\n\n\nbash\n\nsudo chown 100:100 ./projects/vault/certs/vault.key\n\n\n\n검증\n\n\n\n\nbash\n\nsudo ls -l projects/vault/certs\n\n\n\n\n\nbash\n\nsudo openssl x509 -in projects/vault/certs/vault.crt -noout -text | grep -E 'Subject:|DNS:|IP Address'\n\n\n\n\n\n\n\n\nbash\n\nsudo nano projects/vault/docker-compose.yml\n\n\n\n\n\ndocker-compose.yml\n\nservices:\n  vault:\n    image: hashicorp/vault:latest\n    container_name: vault\n    cap_add:\n      - IPC_LOCK\n    environment:\n      VAULT_LOCAL_CONFIG: |\n        {\n          \"storage\": {\"file\": {\"path\": \"/vault/file\"}},\n          \"listener\": [\n            {\"tcp\": { \"address\": \"0.0.0.0:8200\", \"tls_cert_file\": \"/vault/certs/vault.crt\", \"tls_key_file\": \"/vault/certs/vault.key\"}}\n          ],\n          \"default_lease_ttl\": \"168h\",\n          \"max_lease_ttl\": \"720h\",\n          \"ui\": true\n        }\n      VAULT_API_ADDR: \"https://vault:8200\"   # &lt;--- 이 줄만 추가\n    ports:\n      - \"8200:8200\"\n    volumes:\n      - ./file:/vault/file\n      - ./certs:/vault/certs      \n    restart: unless-stopped\n    command: server\n\n\n\n검증\n\n\n\n\nbash\n\ndocker exec -it vault env | grep VAULT_API_ADDR"
  },
  {
    "objectID": "posts/dev/vault.html#vault-정책계정목적-매트릭스-예시",
    "href": "posts/dev/vault.html#vault-정책계정목적-매트릭스-예시",
    "title": "민감정보관리시스템 구축",
    "section": "2 Vault 정책/계정/목적 매트릭스 예시",
    "text": "2 Vault 정책/계정/목적 매트릭스 예시\n\nvault\n\n\n\n\n\n\n\n\n\n정책명(policy)\n계정명(entity/role)\n목적/설명\n\n\n\n\nsvc-nmdose-prod-policy\nsvc-nmdose-prod\nnmdose 운영서비스가 운영 비밀/인증서를 읽기 위해 사용\n\n\nsvc-pseudo_struct-prod-policy\nsvc-pseudo_struct-prod\npseudo_struct 운영서비스가 운영 비밀/인증서를 읽기 위해 사용\n\n\nsvc-openldap-prod-policy\nsvc-openldap-prod\nOpenLDAP 운영서비스의 비밀/인증서 접근\n\n\nsvc-keycloak-prod-policy\nsvc-keycloak-prod\nKeycloak 운영서비스의 비밀/인증서 접근\n\n\nsvc-db-prod-policy\nsvc-db-prod\nDB 접속 정보 등 운영환경 비밀 접근\n\n\nsvc-kibana-prod-policy\nsvc-kibana-prod\nKibana(감사 시스템) 운영환경 비밀 접근\n\n\nsvc-dashboard-prod-policy\nsvc-dashboard-prod\n대시보드/통계 운영환경 비밀 접근\n\n\nsvc-nmdose-dev-policy\nsvc-nmdose-dev\nnmdose 개발환경 비밀/인증서 접근\n\n\nsvc-pseudo_struct-dev-policy\nsvc-pseudo_struct-dev\npseudo_struct 개발환경 비밀/인증서 접근\n\n\nsvc-openldap-dev-policy\nsvc-openldap-dev\nOpenLDAP 개발환경 비밀/인증서 접근\n\n\nsvc-keycloak-dev-policy\nsvc-keycloak-dev\nKeycloak 개발환경 비밀/인증서 접근\n\n\nsvc-db-dev-policy\nsvc-db-dev\nDB 개발환경 비밀 접근\n\n\nsvc-kibana-dev-policy\nsvc-kibana-dev\nKibana 개발환경 비밀 접근\n\n\nsvc-dashboard-dev-policy\nsvc-dashboard-dev\n대시보드 개발환경 비밀 접근\n\n\nsvc-nmdose-stg-policy\nsvc-nmdose-stg\nnmdose 스테이징(테스트) 비밀/인증서 접근\n\n\nsvc-pseudo_struct-stg-policy\nsvc-pseudo_struct-stg\npseudo_struct 스테이징(테스트) 비밀/인증서 접근\n\n\nsvc-openldap-stg-policy\nsvc-openldap-stg\nOpenLDAP 스테이징(테스트) 비밀/인증서 접근\n\n\nsvc-keycloak-stg-policy\nsvc-keycloak-stg\nKeycloak 스테이징(테스트) 비밀/인증서 접근\n\n\nsvc-db-stg-policy\nsvc-db-stg\nDB 스테이징(테스트) 비밀 접근\n\n\nsvc-kibana-stg-policy\nsvc-kibana-stg\nKibana 스테이징(테스트) 비밀 접근\n\n\nsvc-dashboard-stg-policy\nsvc-dashboard-stg\n대시보드 스테이징(테스트) 비밀 접근\n\n\nvault-admin-policy\nvault-admin\nVault 전체 관리, 정책/계정/시스템 설정\n\n\nvault-audit-policy\nvault-audit\nVault 감사(audit) 로그 열람\n\n\nkey-admin-policy\nkey-admin\n전체 인증서/키 관리, PKI 엔진 전담\n\n\npseudo-key-admin-policy\npseudo-key-admin\n가명화키(암복호화) 생성·관리, 로테이션 등\n\n\nldap-secret-admin-policy\nldap-secret-admin\nOpenLDAP 비밀/인증서 생성·관리\n\n\nkeycloak-secret-admin-policy\nkeycloak-secret-admin\nKeycloak 비밀/인증서 생성·관리\n\n\ndb-secret-admin-policy\ndb-secret-admin\nDB 비밀/인증서 생성·관리"
  },
  {
    "objectID": "posts/dev/elk.html",
    "href": "posts/dev/elk.html",
    "title": "중앙 로그관리 시스템",
    "section": "",
    "text": "개발PC의 timezone을 확인하고\n\n\n\n\nbash\n\ntimedatectl\n\n\n\n“컨테이너의 타임존 관리를 위해 호스트의 /etc/localtime 및 /usr/share/zoneinfo를 컨테이너 내부에 바인드 마운트(bind mount)하여 호스트와 동일한 타임존 환경을 보장한다.”\n환경변수에 TZ=Asia/Seoul 설정도 한다.\n\n\n\n\n\n컨테이너별 서비스 uid/gid를 확인해야 한다.\n\n\n\n\nbash\n\n sudo docker exec logstash id\n\n\nlogstash 1000:1000 kibana 1000:1000 elasticsearch 1000:1000"
  },
  {
    "objectID": "posts/dev/elk.html#도커-정보-파악",
    "href": "posts/dev/elk.html#도커-정보-파악",
    "title": "중앙 로그관리 시스템",
    "section": "",
    "text": "개발PC의 timezone을 확인하고\n\n\n\n\nbash\n\ntimedatectl\n\n\n\n“컨테이너의 타임존 관리를 위해 호스트의 /etc/localtime 및 /usr/share/zoneinfo를 컨테이너 내부에 바인드 마운트(bind mount)하여 호스트와 동일한 타임존 환경을 보장한다.”\n환경변수에 TZ=Asia/Seoul 설정도 한다.\n\n\n\n\n\n컨테이너별 서비스 uid/gid를 확인해야 한다.\n\n\n\n\nbash\n\n sudo docker exec logstash id\n\n\nlogstash 1000:1000 kibana 1000:1000 elasticsearch 1000:1000"
  },
  {
    "objectID": "posts/dev/elk.html#docker-정리",
    "href": "posts/dev/elk.html#docker-정리",
    "title": "중앙 로그관리 시스템",
    "section": "2 docker 정리",
    "text": "2 docker 정리\n\n\n\nbash\n\nsudo docker container prune"
  },
  {
    "objectID": "posts/dev/elk.html#elk-stack-설치",
    "href": "posts/dev/elk.html#elk-stack-설치",
    "title": "중앙 로그관리 시스템",
    "section": "3 ELK Stack 설치",
    "text": "3 ELK Stack 설치\n\n3.1 디렉토리 생성\n\n\n\nbash\n\nsudo mkdir -p ~/projects/p31211-r450-pseudo_struct/docker/elk ~/projects/p31211-r450-pseudo_struct/docker/elk/esdata ~/projects/p31211-r450-pseudo_struct/docker/elk/logstash ~/projects/p31211-r450-pseudo_struct/docker/elk/logstash/pipline\n\n\n\n\n\nbash\n\nsudo rm -rf ~/projects/p31211-r450-pseudo_struct/docker\n\n\n\n\n\nbash\n\nsudo chown 1000:1000 ~/projects/p31211-r450-pseudo_struct/docker/elk/esdata ~/projects/p31211-r450-pseudo_struct/docker/elk/logstash ~/projects/p31211-r450-pseudo_struct/docker/elk/logstash/pipline\nsudo chmod 750 ~/projects/p31211-r450-pseudo_struct/docker/elk/esdata ~/projects/p31211-r450-pseudo_struct/docker/elk/logstash ~/projects/p31211-r450-pseudo_struct/docker/elk/logstash/pipline\n\n\n\n검증\n\n\n\n\nbash\n\nsudo ls -ld ~/projects/p31211-r450-pseudo_struct/docker/elk ~/projects/p31211-r450-pseudo_struct/docker/elk/esdata ~/projects/p31211-r450-pseudo_struct/docker/elk/logstash ~/projects/p31211-r450-pseudo_struct/docker/elk/logstash/pipline\n\n\n\n\n3.2 docker-compose.yml 작성\n\n\n\nbash\n\nsudo nano projects/p31211-r450-pseudo_struct/docker-compose.yml\n\n\n\n\n\ndocker-compose.yml\n\nservices:\n  elasticsearch:\n    image: docker.elastic.co/elasticsearch/elasticsearch:8.12.2\n    environment:\n      - discovery.type=single-node\n      - xpack.security.enabled=false\n      - TZ=Asia/Seoul\n    ulimits:\n      memlock:\n        soft: -1\n        hard: -1\n    volumes:\n      - esdata:/usr/share/elasticsearch/data\n      - /etc/localtime:/etc/localtime:ro\n      - /usr/share/zoneinfo:/usr/share/zoneinfo:ro\n    ports:\n      - \"9200:9200\"\n      - \"9300:9300\"      \n    networks:\n      - elk\n\n  logstash:\n    image: docker.elastic.co/logstash/logstash:8.12.2\n    environment:\n      - LS_JAVA_OPTS=-Xms256m -Xmx256m\n      - TZ=Asia/Seoul\n    volumes:\n      - ./logstash/pipeline:/usr/share/logstash/pipeline\n      - /etc/localtime:/etc/localtime:ro\n      - /usr/share/zoneinfo:/usr/share/zoneinfo:ro\n    ports:\n      - \"5044:5044\"\n      - \"5000:5000\"\n      - \"9600:9600\"      \n    depends_on:\n      - elasticsearch\n    networks:\n      - elk\n\n  kibana:\n    image: docker.elastic.co/kibana/kibana:8.12.2\n    environment:\n      - ELASTICSEARCH_HOSTS=http://elasticsearch:9200\n      - TZ=Asia/Seoul\n    ports:\n      - \"5601:5601\"\n    depends_on:\n      - elasticsearch\n    volumes:\n      - /etc/localtime:/etc/localtime:ro\n      - /usr/share/zoneinfo:/usr/share/zoneinfo:ro\n    networks:\n      - elk\n\nvolumes:\n  esdata:\n    driver: local\n\nnetworks:\n  elk:\n    driver: bridge\n\n\n\n아래의 설정으로 3개의 컨테이너는 잘 작동해 보인다.\n\n\n\n\ndocker-compose.yml\n\nservices:\n  elasticsearch:\n    image: docker.elastic.co/elasticsearch/elasticsearch:8.12.2\n    container_name: elasticsearch\n    environment:\n      - discovery.type=single-node\n      - xpack.security.enabled=false   # 개발환경: 인증/암호 off\n    ports:\n      - 9200:9200\n    healthcheck:\n      test: [\"CMD\", \"curl\", \"-s\", \"-f\", \"http://localhost:9200\"]\n      interval: 10s\n      timeout: 10s\n      retries: 10\n\n  logstash:\n    image: docker.elastic.co/logstash/logstash:8.12.2\n    container_name: logstash\n    depends_on:\n      elasticsearch:\n        condition: service_healthy\n    volumes:\n      - ./pipeline:/usr/share/logstash/pipeline\n    ports:\n      - 9600:9600         # logstash API\n      - 5044:5044         # beats input 테스트용 (필요시)\n    environment:\n      - LS_JAVA_OPTS=-Xms512m -Xmx512m\n\n  kibana:\n    image: docker.elastic.co/kibana/kibana:8.12.2\n    container_name: kibana\n    ports:\n      - 5601:5601\n    environment:\n      - ELASTICSEARCH_HOSTS=http://elasticsearch:9200\n    depends_on:\n      elasticsearch:\n        condition: service_healthy\n\n\n\n실제로 로그가 처리되는지 테스트 한다.\n\necho \"테스트 로그 $(date)\" | sudo tee -a /var/log/syslog"
  }
]